<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PAYME — Confirm Transaction (PIN)</title>
  <style>
    :root{ --bg:#fafafa; --card:#fff; --accent:#00a884; --danger:#d9534f; --muted:#666; }
    html,body{height:100%;margin:0;font-family:system-ui,Arial;background:var(--bg);display:flex;align-items:center;justify-content:center}
    .card{width:100%;max-width:420px;background:var(--card);border-radius:12px;padding:20px;box-shadow:0 12px 40px rgba(0,0,0,0.08)}
    h2{margin:0 0 6px}
    p{color:var(--muted);margin:0 0 12px}
    .pin-dots{display:flex;gap:10px;justify-content:center;margin:18px 0}
    .dot{width:56px;height:56px;border-radius:8px;border:1px solid #eee;display:flex;align-items:center;justify-content:center;font-size:24px;background:#fff}
    .keypad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .key{height:64px;border-radius:10px;background:#fff;border:1px solid #eee;display:flex;align-items:center;justify-content:center;font-size:20px;cursor:pointer;user-select:none}
    .row{display:flex;gap:8px;margin-top:12px}
    .btn{flex:1;padding:10px;border-radius:10px;border:0;cursor:pointer}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-outline{background:#fff;border:1px solid #ddd}
    .danger{color:var(--danger);margin-top:8px;text-align:center;display:none}
    .note{color:#666;font-size:13px;text-align:center;margin-top:8px}
    .hidden{display:none}
    .key.disabled { opacity:0.6; pointer-events:none; }
  </style>
</head>
<body>
  <div class="card" role="dialog" aria-modal="true">
    <h2>Enter your 4-digit PIN</h2>
    <p>Confirm this transaction with the PIN linked to your account.</p>

    <div class="pin-dots" id="pinDots" aria-hidden="false">
      <div class="dot" data-index="0" aria-hidden="true"></div>
      <div class="dot" data-index="1" aria-hidden="true"></div>
      <div class="dot" data-index="2" aria-hidden="true"></div>
      <div class="dot" data-index="3" aria-hidden="true"></div>
    </div>

    <div id="message" class="note">Type your 4-digit PIN</div>
    <div id="error" class="danger" role="alert"></div>

    <div class="keypad" id="keypad" aria-label="PIN keypad" style="margin-top:14px">
      <div class="key" role="button" tabindex="0">1</div><div class="key" role="button" tabindex="0">2</div><div class="key" role="button" tabindex="0">3</div>
      <div class="key" role="button" tabindex="0">4</div><div class="key" role="button" tabindex="0">5</div><div class="key" role="button" tabindex="0">6</div>
      <div class="key" role="button" tabindex="0">7</div><div class="key" role="button" tabindex="0">8</div><div class="key" role="button" tabindex="0">9</div>
      <div class="key" id="blank" aria-hidden="true"></div><div class="key" role="button" tabindex="0">0</div><div class="key" id="back" role="button" tabindex="0" aria-label="Backspace">⌫</div>
    </div>

    <div class="row" style="margin-top:18px">
      <button id="cancelBtn" class="btn btn-outline">Cancel</button>
      <button id="submitBtn" class="btn btn-primary" disabled>Verify & Pay</button>
    </div>
  </div>

<script>
  (function(){
    // --- CONFIG --- change API_BASE if needed
    const API_BASE = "https://payme-update.onrender.com";
    // Use your backend route
    const SEND_MONEY_ROUTE = API_BASE + "/send_money";  // <-- now matches your backend
    const BUY_AIRTIME = API_BASE + "/buy_airtime";      // unchanged

    // DOM
    const keypad = document.getElementById('keypad');
    const pinDots = Array.from(document.querySelectorAll('.dot'));
    const message = document.getElementById('message');
    const errorEl = document.getElementById('error');
    const submitBtn = document.getElementById('submitBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    // Lock config
    const LOCK_THRESHOLD = 3;
    const LOCK_DURATION_MS = 4 * 60 * 60 * 1000; // 4 hours
    const STATUS_POLL_MS = 8000; // poll server every 8s for cross-browser sync

    // Storage helpers
    function getStoredUser() {
      const j = localStorage.getItem("loggedInUser") || localStorage.getItem("user");
      try { return j ? JSON.parse(j) : null; } catch(e){ return null; }
    }
    function getPendingFromSession() { try { const p = sessionStorage.getItem('pending_tx'); return p ? JSON.parse(p) : null; } catch(e){ return null; } }
    function clearPending() { try { sessionStorage.removeItem('pending_tx'); } catch(e){} }

    function getPendingFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const phone = params.get('phone') || params.get('recipient') || null;
      const network = params.get('network') || null;
      const amount = params.get('amount') || params.get('amt') || null;
      const receiver_acc = params.get('receiver_acc') || params.get('receiver') || null;
      if (!phone && !network && !amount && !receiver_acc) return null;
      return {
        product: params.get('product') || (network ? 'airtime' : null),
        phone,
        recipient: params.get('recipient_name') || params.get('receiver_name') || params.get('recipient') || null,
        receiver_acc,
        recipientAccount: receiver_acc,
        network,
        amount,
        created_at: new Date().toISOString()
      };
    }

    // pending (session first then url)
    let pending = getPendingFromSession() || getPendingFromUrl();

    // pin state & lock
    let current = '';
    let lockInfo = null;
    let lockKey = null;
    let countdownInterval = null;
    let statusPollInterval = null;

    function getLockKeyForAccount(accountId){ return `pin_lock_${accountId || 'anonymous'}`; }
    function loadLockInfo(){ try { const raw = localStorage.getItem(lockKey); if (!raw) return { failedAttempts: 0, lockedUntil: null }; const parsed = JSON.parse(raw); return { failedAttempts: parsed.failedAttempts || 0, lockedUntil: parsed.lockedUntil || null }; } catch(e){ return { failedAttempts: 0, lockedUntil: null }; } }
    function saveLockInfo(info){ try { localStorage.setItem(lockKey, JSON.stringify(info)); } catch(e){ console.warn('saveLockInfo failed', e); } lockInfo = info; broadcastLockChange(info); }
    function clearLockInfo(){ try { localStorage.removeItem(lockKey); } catch(e){} lockInfo = { failedAttempts:0, lockedUntil: null }; enableKeypad(); updateMessageFromPending(); if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; } }
    function isLocked(){ if (!lockInfo || !lockInfo.lockedUntil) return false; try { return (new Date(lockInfo.lockedUntil) > new Date()); } catch(e){ return false; } }
    function formatRemaining(ms){ if (ms <= 0) return '0s'; const totalSec = Math.floor(ms/1000); const hrs = Math.floor(totalSec / 3600); const mins = Math.floor((totalSec % 3600) / 60); const secs = totalSec % 60; if (hrs > 0) return `${hrs}h ${mins}m`; if (mins > 0) return `${mins}m ${secs}s`; return `${secs}s`; }
    function disableKeypad(){ keypad.querySelectorAll('.key').forEach(k => k.classList.add('disabled')); submitBtn.disabled = true; }
    function enableKeypad(){ keypad.querySelectorAll('.key').forEach(k => k.classList.remove('disabled')); submitBtn.disabled = (current.length !== 4); }
    function setLockCountdown(){ if (!lockInfo || !lockInfo.lockedUntil) return; if (countdownInterval) clearInterval(countdownInterval); countdownInterval = setInterval(()=> { const until = new Date(lockInfo.lockedUntil); const msLeft = until - new Date(); if (msLeft <= 0) { clearInterval(countdownInterval); countdownInterval = null; // re-sync with server after countdown
        fetchStatusAndUpdateUI();
        return; } message.textContent = `Too many failed attempts. Try again in ${formatRemaining(msLeft)}.`; }, 1000); }

    // BroadcastChannel for cross-tab quick sync (graceful fallback if unsupported)
    let bc = null;
    try { bc = new BroadcastChannel('payme_pin_channel'); bc.onmessage = (ev) => { if (ev && ev.data && ev.data.type === 'lock_update') { lockInfo = ev.data.info || lockInfo; applyLockInfoToUI(); } }; } catch(e){ bc = null; }
    function broadcastLockChange(info){ try { if (bc) bc.postMessage({ type:'lock_update', info }); } catch(e){} }

    function refreshDots(){ pinDots.forEach((d,i)=> { const ch = current[i] || ''; d.textContent = ch ? '•' : ''; d.classList.toggle('filled', !!ch); }); submitBtn.disabled = (current.length !== 4) || isLocked(); }
    function showError(msg){ errorEl.style.display='block'; errorEl.textContent = msg; }
    function clearError(){ errorEl.style.display='none'; errorEl.textContent=''; }

    function updateMessageFromPending(){
      if (!pending) {
        message.textContent = 'No pending transaction — go back and try again.';
        submitBtn.disabled = true;
        return;
      }
      if (pending.product === 'towallet' || pending.receiver_acc) {
        const recv = pending.receiver_acc || pending.recipient || pending.phone || '-';
        const bank = pending.receiver_bank_name || pending.receiver_bank || pending.bankName || '';
        message.textContent = `Confirm ₦${Number(pending.amount || 0).toLocaleString()} to ${recv}${bank ? ' ('+bank+')' : ''}`;
        return;
      }
      const recipient = pending.recipient || pending.phone || '-';
      const network = pending.network || '-';
      message.textContent = `Confirm ₦${Number(pending.amount || 0).toLocaleString()} to ${recipient} (${network})`;
    }

    function incrementFailedAndMaybeLock(){
      const now = new Date();
      lockInfo.failedAttempts = (lockInfo.failedAttempts || 0) + 1;
      if (lockInfo.failedAttempts >= LOCK_THRESHOLD) {
        const until = new Date(now.getTime() + LOCK_DURATION_MS);
        lockInfo.lockedUntil = until.toISOString();
        saveLockInfo(lockInfo);
        disableKeypad();
        message.textContent = `Too many failed attempts. Transactions suspended until ${until.toLocaleString()}`;
        setLockCountdown();
      } else {
        saveLockInfo(lockInfo);
        const left = LOCK_THRESHOLD - lockInfo.failedAttempts;
        showError(`Invalid PIN. ${left} attempt${left>1?'s':''} left before lock.`);
      }
    }

    // Apply lockInfo to UI (used after server status fetch or BroadcastChannel update)
    function applyLockInfoToUI(){
      if (!lockInfo) return;
      if (lockInfo.lockedUntil && (new Date(lockInfo.lockedUntil) > new Date())) {
        disableKeypad();
        message.textContent = `Too many failed attempts. Try again in ${formatRemaining(new Date(lockInfo.lockedUntil) - new Date())}.`;
        setLockCountdown();
      } else {
        // not locked
        if (lockInfo.failedAttempts && lockInfo.failedAttempts > 0) {
          const left = Math.max(0, LOCK_THRESHOLD - lockInfo.failedAttempts);
          if (left > 0) {
            showError(`Invalid PIN. ${left} attempt${left>1?'s':''} left before lock.`);
            // keep keypad enabled
            enableKeypad();
          } else {
            // show lock message fallback
            disableKeypad();
            message.textContent = 'Too many failed attempts. Try again later.';
          }
        } else {
          clearError();
          enableKeypad();
          updateMessageFromPending();
        }
      }
    }

    // Server status sync: GET /api/pin/status -> expects { hasPin, locked, lockedUntil, failedAttempts }
    async function fetchStatusAndUpdateUI(){
      try {
        const res = await fetch(`${API_BASE}/api/pin/status`, { method:'GET', credentials:'include', headers:{ 'Accept':'application/json' } });
        if (!res.ok) {
          // If unauthenticated or server error, ignore and keep local state
          // If 401, server says not logged in; leave UI but show hint
          if (res.status === 401) {
            // not logged in; preserve local behaviour
            return;
          }
          return;
        }
        const j = await res.json().catch(()=>null);
        if (!j) return;
        // Normalize into lockInfo
        const fi = Number(j.failedAttempts || 0);
        const locked = !!j.locked;
        const lockedUntil = j.lockedUntil || null;
        lockInfo = { failedAttempts: fi, lockedUntil: locked ? lockedUntil : null };
        // persist locally so other tabs read it
        try { if (lockKey) localStorage.setItem(lockKey, JSON.stringify(lockInfo)); } catch(e){}
        broadcastLockChange(lockInfo);
        applyLockInfoToUI();
      } catch (err) {
        // ignore network errors
        console.warn('Status fetch failed', err);
      }
    }

    // Start periodic polling to keep browsers in sync
    function startStatusPolling(){
      if (statusPollInterval) clearInterval(statusPollInterval);
      statusPollInterval = setInterval(fetchStatusAndUpdateUI, STATUS_POLL_MS);
    }

    // keypad wiring
    keypad.addEventListener('click', ev=>{
      const k = ev.target;
      if (!k.classList.contains('key')) return;
      if (isLocked()) return;
      handleKey(k);
    });
    keypad.addEventListener('keydown', ev=>{
      if (ev.key === 'Enter' || ev.key === ' ') {
        const k = document.activeElement;
        if (k && k.classList.contains('key')) {
          ev.preventDefault();
          if (isLocked()) return;
          handleKey(k);
        }
      }
    });
    function handleKey(k){
      if (k.id === 'back') { current = current.slice(0,-1); clearError(); refreshDots(); return; }
      if (k.id === 'blank') return;
      if (current.length >= 4) return;
      current += (k.textContent || '').trim();
      refreshDots();
    }

    cancelBtn.addEventListener('click', ()=> {
      if (pending && pending.product === 'towallet') window.location.href = 'towallet.html';
      else window.location.href = 'airtime.html';
    });

    function getReturnUrl() {
      try {
        const explicit = sessionStorage.getItem('return_to');
        if (explicit) return explicit;
        if (document.referrer && document.referrer !== '') return document.referrer;
        if (pending && pending.product) {
          if (pending.product === 'data') return 'data.html';
          if (pending.product === 'airtime') return 'airtime.html';
          if (pending.product === 'towallet') return 'towallet.html';
        }
      } catch(e){}
      return 'airtime.html';
    }

    // --- Execution helpers that match your backend (/send_money) ---
    async function executeTowallet(pending, user) {
      if (!pending) return { ok:false, error:'No pending' };
      if (!user) return { ok:false, error:'No logged-in user' };

      // Construct payload to exactly match backend expectations:
      // backend expects: sender_phone, receiver_acc, amount
      const senderPhone = (pending.sender_phone || pending.phone || user.phone || '');
      const receiverAccVal = (pending.receiver_acc || pending.recipientAccount || pending.recipient || '');
      const amountVal = Number(pending.amount);

      if (!receiverAccVal) return { ok:false, error:'Missing receiver_acc in pending transaction.' };
      if (!senderPhone) return { ok:false, error:'Missing sender phone' };

      const txPayload = {
        sender_phone: String(senderPhone).trim(),
        receiver_acc: String(receiverAccVal).trim(),
        amount: amountVal
      };

      const headers = { 'Content-Type':'application/json', 'Accept':'application/json' };
      // If you use token auth instead of cookies, add:
      // headers['Authorization'] = 'Bearer ' + (localStorage.getItem('authToken') || '');

      try {
        const execRes = await fetch(SEND_MONEY_ROUTE, {
          method: 'POST',
          credentials: 'include', // keep cookies; adjust if you use token auth
          headers,
          body: JSON.stringify(txPayload)
        });

        const execJson = await execRes.json().catch(()=>null);

        if (!execRes.ok) {
          // backend returned an error, pass message to caller
          const reason = (execJson && (execJson.message || execJson.error)) || `HTTP ${execRes.status}`;
          return { ok:false, error: reason, detail: execJson };
        }

        // backend success shape (per your server) includes 'status': 'success' and we now expect 'sender_new_balance'
        if (!(execJson && execJson.status === 'success')) {
          const reason = (execJson && (execJson.message || execJson.error)) || 'Unknown server response';
          return { ok:false, error: reason, detail: execJson };
        }

        // Prefer sender_new_balance (your patched backend returns this)
        const newBalance = execJson.sender_new_balance ?? execJson.new_balance ?? execJson.balance ?? null;

        const successPayload = {
          type: 'success',
          message: execJson.message || 'Transfer successful',
          amount: pending.amount,
          orderAmount: pending.amount,
          datetime: new Date().toLocaleString(),
          sender: pending.sender || (user.username || user.name) || 'You',
          senderAccount: pending.senderAccount || (user.account_number || user.accountNumber) || '-',
          bankName: pending.receiver_bank_name || pending.receiver_bank || 'PAYME',
          recipient: pending.recipient || receiverAccVal,
          recipientAccount: pending.recipientAccount || receiverAccVal,
          txnNo: execJson.transaction_id || execJson.txn_id || execJson.reference || execJson.transaction_id || '-',
          statusText: 'Successful',
          raw: execJson
        };

        // Save result for the transfer page to show success
        sessionStorage.setItem('last_tx_success', JSON.stringify(successPayload));

        // Update localStorage and stored user objects with new sender balance if provided
        if (newBalance !== null && !isNaN(Number(newBalance))) {
          try { localStorage.setItem('balance', String(newBalance)); } catch(e){}
          try {
            const stored = localStorage.getItem('loggedInUser');
            if (stored) { const u = JSON.parse(stored); u.balance = Number(newBalance); localStorage.setItem('loggedInUser', JSON.stringify(u)); }
          } catch(e){}
          try {
            const stored2 = localStorage.getItem('user');
            if (stored2) { const u2 = JSON.parse(stored2); u2.balance = Number(newBalance); localStorage.setItem('user', JSON.stringify(u2)); }
          } catch(e){}

          // Broadcast update to other tabs (fast) and fallback to storage event
          try { const bc2 = new BroadcastChannel('payme_channel'); bc2.postMessage({ type:'balance_update', balance: Number(newBalance), reference: successPayload.txnNo }); bc2.close(); }
          catch(e) { try { localStorage.setItem('payme_balance_update', JSON.stringify({ balance: Number(newBalance), ts: Date.now(), reference: successPayload.txnNo })); } catch(e){} }
        }

        // Remove pending so it cannot be reused
        sessionStorage.removeItem('pending_tx');

        return { ok:true, payload: successPayload, raw: execJson };

      } catch (err) {
        console.error('executeTowallet error', err);
        return { ok:false, error:'Network error while executing transaction', detail: String(err) };
      }
    }

    // simple airtime fallback (unchanged)
    async function executeAirtime(pending, user) {
      const txPayload = { phone: pending.phone || pending.recipient, network: pending.network, amount: pending.amount, recipient: pending.recipient };
      try {
        const execRes = await fetch(BUY_AIRTIME, { method:'POST', credentials:'include', headers:{'Content-Type':'application/json'}, body: JSON.stringify(txPayload) });
        const execJson = await execRes.json().catch(()=>null);
        if (!execRes.ok || !(execJson && (execJson.status === 'success' || execJson.success === true))) {
          const reason = (execJson && (execJson.message || execJson.error)) || `HTTP ${execRes.status}`;
          return { ok:false, error: reason, detail: execJson };
        }
        const successPayload = { message: execJson.message || 'Airtime purchased successfully', amount: pending.amount, network: pending.network, recipient: pending.recipient || pending.phone, datetime: new Date().toISOString(), statusText: 'Successful', raw: execJson };
        sessionStorage.setItem('last_tx_success', JSON.stringify(successPayload));
        sessionStorage.removeItem('pending_tx');
        return { ok:true, payload: successPayload, raw: execJson };
      } catch (err) { console.error('executeAirtime error', err); return { ok:false, error:'Network error while executing airtime', detail: String(err) }; }
    }

    // Submit flow
    submitBtn.addEventListener('click', async ()=>{
      clearError();
      if (isLocked()) {
        const until = lockInfo && lockInfo.lockedUntil ? new Date(lockInfo.lockedUntil) : null;
        if (until) showError(`Too many failed attempts. Try again in ${formatRemaining(until - new Date())}.`);
        else showError('Too many failed attempts. Try later.');
        return;
      }
      if (!pending) { showError('No pending transaction found. Go back and try again.'); return; }
      const user = getStoredUser();
      if (!user || !(user.account_number || user.accountNumber || user.phone)) { showError('You must be logged in. Please log in and try again.'); return; }

      // setup lock info
      const acctId = (user.account_number || user.accountNumber) || user.phone;
      if (!lockKey) lockKey = getLockKeyForAccount(acctId);
      if (!lockInfo) lockInfo = loadLockInfo();

      // Verify PIN with your backend
      const accountNumber = (user.account_number || user.accountNumber || '').toString();
      const payload = { account_number: accountNumber, pin: current };

      try {
        submitBtn.disabled = true; submitBtn.textContent = 'Verifying...';
        const res = await fetch(`${API_BASE}/api/pin/verify`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const j = await res.json().catch(()=>({ success:false, message: 'Invalid server response' }));

        if (res.ok && j.success) {
          // reset lock info
          saveLockInfo({ failedAttempts: 0, lockedUntil: null });

          // execute the right flow
          let result;
          if (pending.product === 'towallet' || pending.receiver_acc) {
            result = await executeTowallet(pending, user);
          } else {
            result = await executeAirtime(pending, user);
          }

          if (result.ok) {
            // redirect back to the page which will show the success modal
            const returnUrl = getReturnUrl();
            window.location.href = returnUrl;
            return;
          } else {
            showError('Transaction failed: ' + (result.error || 'Unknown error'));
            console.error('execution error detail', result.detail || result);
            // Do not increment PIN lock — PIN was valid
          }

        } else {
          // If server indicates locked -> obey it (authoritative)
          if (res.status === 403 && j && j.lockedUntil) {
            lockInfo = lockInfo || {};
            lockInfo.failedAttempts = LOCK_THRESHOLD;
            lockInfo.lockedUntil = j.lockedUntil;
            saveLockInfo(lockInfo);
            disableKeypad();
            message.textContent = `Too many failed attempts. Try again in ${formatRemaining(new Date(j.lockedUntil) - new Date())}.`;
            setLockCountdown();
            showError(j.message || 'Account locked due to failed attempts.');
            return;
          }

          // Invalid PIN (401) -> ask server for authoritative failedAttempts and show remaining attempts
          if (res.status === 401) {
            // fetch latest status from server (so other browsers' attempts are known)
            await fetchStatusAndUpdateUI();
            lockInfo = lockInfo || loadLockInfo();
            // If server returned remaining info in body, prefer that
            const serverFailed = typeof j.failedAttempts !== 'undefined' ? Number(j.failedAttempts) : (lockInfo.failedAttempts || 0);
            const left = Math.max(0, LOCK_THRESHOLD - serverFailed);
            if (left > 0) showError(`Invalid PIN. ${left} attempt${left>1?'s':''} left before lock.`);
            else showError('Invalid PIN.');
            // update local counters if server told us
            try {
              // keep local copy in sync
              if (!lockKey) lockKey = getLockKeyForAccount(acctId);
              saveLockInfo({ failedAttempts: serverFailed, lockedUntil: lockInfo.lockedUntil || null });
            } catch (e){}
            current = '';
            refreshDots();
            return;
          }

          // other server errors
          showError(j.message || `Failed to save PIN (HTTP ${res.status})`);
          console.warn('pin verify error body', j);
          submitBtn.disabled = false;
          submitBtn.textContent = 'Verify & Pay';
          return;
        }
      } catch (err) {
        console.error('verify error', err);
        showError('Network error while verifying PIN');
        return;
      } finally {
        submitBtn.disabled = false; submitBtn.textContent = 'Verify & Pay';
      }
    });

    (function init(){
      const user = getStoredUser();
      const acctId = user ? ((user.account_number || user.accountNumber) || user.phone) : 'anonymous';
      lockKey = getLockKeyForAccount(acctId);
      lockInfo = loadLockInfo();

      // Immediately try to sync with server (authoritative). This makes lock state shared across browsers.
      fetchStatusAndUpdateUI().catch(()=>{ /* ignore */ });
      // Start periodic polling for cross-browser sync
      startStatusPolling();

      if (isLocked()) {
        disableKeypad();
        const until = new Date(lockInfo.lockedUntil);
        message.textContent = `Too many failed attempts. Try again in ${formatRemaining(until - new Date())}.`;
        setLockCountdown();
      } else {
        if (lockInfo.lockedUntil) clearLockInfo();
      }

      if (!pending) {
        const params = new URLSearchParams(window.location.search);
        const debugList = [];
        if (!params.get('phone') && !params.get('recipient')) debugList.push('phone/recipient');
        if (!params.get('network')) debugList.push('network');
        if (!params.get('amount')) debugList.push('amount');
        if (!params.get('receiver_acc') && !sessionStorage.getItem('pending_tx')) debugList.push('receiver_acc (for towallet)');
        if (debugList.length) {
          message.textContent = 'Missing fields: ' + debugList.join(', ') + '. Please return and retry.';
        } else {
          message.textContent = 'No pending transaction found. Go back and try again.';
        }
        submitBtn.disabled = true;
      } else {
        updateMessageFromPending();
        refreshDots();
      }
    })();

    // If BroadcastChannel not supported, also listen to storage events (fallback)
    window.addEventListener('storage', (ev)=>{
      if (!ev.key || !lockKey) return;
      if (ev.key === lockKey) {
        try { lockInfo = JSON.parse(ev.newValue || '{}'); applyLockInfoToUI(); } catch(e){}
      }
    });

    document.querySelectorAll('.key').forEach(k => { k.setAttribute('tabindex', '0'); });

    // Expose a small debug helper for manual re-sync if needed
    window._payme_pin_force_sync = fetchStatusAndUpdateUI;

  })();
</script>
</body>
</html>