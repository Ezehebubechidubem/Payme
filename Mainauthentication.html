<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PAYME — Confirm Transaction (PIN)</title>
  <style>
    :root{ --bg:#fafafa; --card:#fff; --accent:#00a884; --danger:#d9534f; --muted:#666; }
    html,body{height:100%;margin:0;font-family:system-ui,Arial;background:var(--bg);display:flex;align-items:center;justify-content:center}
    .card{width:100%;max-width:420px;background:var(--card);border-radius:12px;padding:20px;box-shadow:0 12px 40px rgba(0,0,0,0.08)}
    h2{margin:0 0 6px}
    p{color:var(--muted);margin:0 0 12px}
    .pin-dots{display:flex;gap:10px;justify-content:center;margin:18px 0}
    .dot{width:56px;height:56px;border-radius:8px;border:1px solid #eee;display:flex;align-items:center;justify-content:center;font-size:24px;background:#fff}
    .keypad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .key{height:64px;border-radius:10px;background:#fff;border:1px solid #eee;display:flex;align-items:center;justify-content:center;font-size:20px;cursor:pointer;user-select:none}
    .row{display:flex;gap:8px;margin-top:12px}
    .btn{flex:1;padding:10px;border-radius:10px;border:0;cursor:pointer}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-outline{background:#fff;border:1px solid #ddd}
    .danger{color:var(--danger);margin-top:8px;text-align:center;display:none}
    .note{color:#666;font-size:13px;text-align:center;margin-top:8px}
    .hidden{display:none}
    .key.disabled { opacity:0.6; pointer-events:none; }
  </style>
</head>
<body>
  <div class="card" role="dialog" aria-modal="true">
    <h2>Enter your 4-digit PIN</h2>
    <p>Confirm this transaction with the PIN linked to your account.</p>

    <div class="pin-dots" id="pinDots" aria-hidden="false">
      <div class="dot" data-index="0" aria-hidden="true"></div>
      <div class="dot" data-index="1" aria-hidden="true"></div>
      <div class="dot" data-index="2" aria-hidden="true"></div>
      <div class="dot" data-index="3" aria-hidden="true"></div>
    </div>

    <div id="message" class="note">Type your 4-digit PIN</div>
    <div id="error" class="danger" role="alert"></div>

    <div class="keypad" id="keypad" aria-label="PIN keypad" style="margin-top:14px">
      <div class="key" role="button" tabindex="0">1</div><div class="key" role="button" tabindex="0">2</div><div class="key" role="button" tabindex="0">3</div>
      <div class="key" role="button" tabindex="0">4</div><div class="key" role="button" tabindex="0">5</div><div class="key" role="button" tabindex="0">6</div>
      <div class="key" role="button" tabindex="0">7</div><div class="key" role="button" tabindex="0">8</div><div class="key" role="button" tabindex="0">9</div>
      <div class="key" id="blank" aria-hidden="true"></div><div class="key" role="button" tabindex="0">0</div><div class="key" id="back" role="button" tabindex="0" aria-label="Backspace">⌫</div>
    </div>

    <div class="row" style="margin-top:18px">
      <button id="cancelBtn" class="btn btn-outline">Cancel</button>
      <button id="submitBtn" class="btn btn-primary" disabled>Verify & Pay</button>
    </div>
  </div>

<script>
  (function(){
    const API_BASE = "https://payme-update.onrender.com";
    const TOWALLET_SEND = API_BASE + "/towallet/send_money";
    const BUY_AIRTIME = API_BASE + "/buy_airtime";
    const keypad = document.getElementById('keypad');
    const pinDots = Array.from(document.querySelectorAll('.dot'));
    const message = document.getElementById('message');
    const errorEl = document.getElementById('error');
    const submitBtn = document.getElementById('submitBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    const LOCK_THRESHOLD = 3;               // 3 failed attempts
    const LOCK_DURATION_MS = 4 * 60 * 60 * 1000; // 4 hours

    function getStoredUser() {
      const j = localStorage.getItem("loggedInUser") || localStorage.getItem("user");
      try { return j ? JSON.parse(j) : null; } catch(e){ return null; }
    }

    function getPendingFromSession() {
      try { const p = sessionStorage.getItem('pending_tx'); return p ? JSON.parse(p) : null; } catch(e){ return null; }
    }
    function clearPending() {
      try { sessionStorage.removeItem('pending_tx'); } catch(e){}
    }

    // Also permit old url-based flows (if someone navigates via query params)
    function getPendingFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const phone = params.get('phone') || params.get('recipient') || params.get('to') || null;
      const network = params.get('network') || params.get('operator') || null;
      const amount = params.get('amount') || params.get('amt') || null;
      // Accept receiver_acc and variants from URL
      const receiver_acc = params.get('receiver_acc') || params.get('receiver') || params.get('recipient_acc') || params.get('recipientAccount') || null;
      const recipientName = params.get('recipient_name') || params.get('receiver_name') || params.get('recipient') || null;
      const product = params.get('product') || (network ? 'airtime' : null);
      if (!phone && !network && !amount && !receiver_acc) return null;
      return {
        product,
        phone,
        recipient: recipientName || phone,
        receiver_acc: receiver_acc,
        recipientAccount: receiver_acc,
        network,
        amount,
        created_at: new Date().toISOString()
      };
    }

    // Unified pending object: prefer sessionStorage.pending_tx, else URL
    let pending = getPendingFromSession() || getPendingFromUrl();

    // For lock storage
    let current = '';
    let lockInfo = null;   // { failedAttempts, lockedUntilISO }
    let lockKey = null;
    let countdownInterval = null;

    function getLockKeyForAccount(accountId){
      return `pin_lock_${accountId || 'anonymous'}`;
    }
    function loadLockInfo(){
      try {
        const raw = localStorage.getItem(lockKey);
        if (!raw) return { failedAttempts: 0, lockedUntil: null };
        const parsed = JSON.parse(raw);
        return { failedAttempts: parsed.failedAttempts || 0, lockedUntil: parsed.lockedUntil || null };
      } catch(e){ return { failedAttempts: 0, lockedUntil: null }; }
    }
    function saveLockInfo(info){
      try { localStorage.setItem(lockKey, JSON.stringify(info)); } catch(e){ console.warn('saveLockInfo failed', e); }
      lockInfo = info;
    }
    function clearLockInfo(){
      try { localStorage.removeItem(lockKey); } catch(e){}
      lockInfo = { failedAttempts:0, lockedUntil: null };
      enableKeypad();
      updateMessageFromPending();
      if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
    }
    function isLocked(){
      if (!lockInfo || !lockInfo.lockedUntil) return false;
      try { return (new Date(lockInfo.lockedUntil) > new Date()); } catch(e){ return false; }
    }
    function formatRemaining(ms){
      if (ms <= 0) return '0s';
      const totalSec = Math.floor(ms/1000);
      const hrs = Math.floor(totalSec / 3600);
      const mins = Math.floor((totalSec % 3600) / 60);
      const secs = totalSec % 60;
      if (hrs > 0) return `${hrs}h ${mins}m`;
      if (mins > 0) return `${mins}m ${secs}s`;
      return `${secs}s`;
    }
    function disableKeypad(){ keypad.querySelectorAll('.key').forEach(k => k.classList.add('disabled')); submitBtn.disabled = true; }
    function enableKeypad(){ keypad.querySelectorAll('.key').forEach(k => k.classList.remove('disabled')); submitBtn.disabled = (current.length !== 4); }
    function setLockCountdown(){
      if (!lockInfo || !lockInfo.lockedUntil) return;
      if (countdownInterval) clearInterval(countdownInterval);
      countdownInterval = setInterval(()=> {
        const until = new Date(lockInfo.lockedUntil);
        const msLeft = until - new Date();
        if (msLeft <= 0) { clearInterval(countdownInterval); countdownInterval = null; clearLockInfo(); return; }
        message.textContent = `Too many failed attempts. Try again in ${formatRemaining(msLeft)}.`;
      }, 1000);
    }

    function refreshDots(){
      pinDots.forEach((d,i)=> { const ch = current[i] || ''; d.textContent = ch ? '•' : ''; d.classList.toggle('filled', !!ch); });
      submitBtn.disabled = (current.length !== 4) || isLocked();
    }
    function showError(msg){ errorEl.style.display='block'; errorEl.textContent = msg; }
    function clearError(){ errorEl.style.display='none'; errorEl.textContent=''; }

    function updateMessageFromPending(){
      if (!pending) {
        message.textContent = 'No pending transaction — go back and try again.';
        submitBtn.disabled = true;
        return;
      }
      // If it's a towallet pending (we support towallet object shape)
      if (pending.product === 'towallet' || pending.receiver_acc) {
        const recv = pending.receiver_acc || pending.recipient || pending.phone || '-';
        const bank = pending.receiver_bank_name || pending.receiver_bank || pending.bankName || '';
        message.textContent = `Confirm ₦${Number(pending.amount || 0).toLocaleString()} to ${recv}${bank ? ' ('+bank+')' : ''}`;
        return;
      }
      // default airtime/data flows
      const recipient = pending.recipient || pending.phone || '-';
      const network = pending.network || '-';
      message.textContent = `Confirm ₦${Number(pending.amount || 0).toLocaleString()} to ${recipient} (${network})`;
    }

    function incrementFailedAndMaybeLock(){
      const now = new Date();
      lockInfo.failedAttempts = (lockInfo.failedAttempts || 0) + 1;
      if (lockInfo.failedAttempts >= LOCK_THRESHOLD) {
        const until = new Date(now.getTime() + LOCK_DURATION_MS);
        lockInfo.lockedUntil = until.toISOString();
        saveLockInfo(lockInfo);
        disableKeypad();
        message.textContent = `Too many failed attempts. Transactions suspended until ${until.toLocaleString()}`;
        setLockCountdown();
      } else {
        saveLockInfo(lockInfo);
        const left = LOCK_THRESHOLD - lockInfo.failedAttempts;
        showError(`Invalid PIN. ${left} attempt${left>1?'s':''} left before lock.`);
      }
    }

    // keypad wiring
    keypad.addEventListener('click', ev=>{
      const k = ev.target;
      if (!k.classList.contains('key')) return;
      if (isLocked()) return;
      handleKey(k);
    });
    keypad.addEventListener('keydown', ev=>{
      if (ev.key === 'Enter' || ev.key === ' ') {
        const k = document.activeElement;
        if (k && k.classList.contains('key')) {
          ev.preventDefault();
          if (isLocked()) return;
          handleKey(k);
        }
      }
    });
    function handleKey(k){
      if (k.id === 'back') { current = current.slice(0,-1); clearError(); refreshDots(); return; }
      if (k.id === 'blank') return;
      if (current.length >= 4) return;
      current += (k.textContent || '').trim();
      refreshDots();
    }

    cancelBtn.addEventListener('click', ()=> {
      if (pending && pending.product === 'towallet') window.location.href = 'towallet.html';
      else window.location.href = 'airtime.html';
    });

    // Determine return URL (last page before Mainauthentication)
    function getReturnUrl() {
      try {
        const explicit = sessionStorage.getItem('return_to');
        if (explicit) return explicit;
        if (document.referrer && document.referrer !== '') return document.referrer;
        if (pending && pending.product) {
          if (pending.product === 'data') return 'data.html';
          if (pending.product === 'airtime') return 'airtime.html';
          if (pending.product === 'towallet') return 'towallet.html';
        }
      } catch(e){}
      return 'airtime.html';
    }

    // Main verify & execute flow
    submitBtn.addEventListener('click', async ()=>{
      clearError();
      if (isLocked()) {
        const until = lockInfo && lockInfo.lockedUntil ? new Date(lockInfo.lockedUntil) : null;
        if (until) showError(`Too many failed attempts. Try again in ${formatRemaining(until - new Date())}.`);
        else showError('Too many failed attempts. Try later.');
        return;
      }

      if (!pending) {
        showError('No pending transaction found. Go back and try again.');
        return;
      }

      const user = getStoredUser();
      if (!user || !(user.account_number || user.accountNumber || user.phone)) {
        showError('You must be logged in. Please log in and try again.');
        return;
      }

      // lock key setup
      const acctId = (user.account_number || user.accountNumber) || user.phone;
      if (!lockKey) lockKey = getLockKeyForAccount(acctId);
      if (!lockInfo) lockInfo = loadLockInfo();

      const accountNumber = (user.account_number || user.accountNumber || '').toString();
      const payload = { account_number: accountNumber, pin: current };

      try {
        // verify PIN
        const res = await fetch(`${API_BASE}/api/pin/verify`, {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const j = await res.json().catch(()=>({ success:false, message: 'Invalid server response' }));

        if (res.ok && j.success) {
          // reset lock info
          saveLockInfo({ failedAttempts: 0, lockedUntil: null });

          // Execute based on pending.product
          if (pending.product === 'towallet' || pending.receiver_acc) {
            // Build towallet execution payload — ensure receiver_acc present and include multiple compatible keys
            const senderPhone = pending.sender_phone || pending.phone || user.phone || null;
            const receiverAccVal = (pending.receiver_acc || pending.recipientAccount || pending.recipient || pending.receiver || pending.recipient_account) || null;

            const txPayload = {
              sender_phone: senderPhone,
              phone: senderPhone,                    // some backends expect `phone`
              receiver_acc: receiverAccVal,
              recipient: pending.recipient || pending.receiver_name || undefined,
              amount: pending.amount,
              receiver_bank: pending.receiver_bank || pending.receiver_bank_name || pending.receiver_bank_code || 'PAYME'
            };

            // debug log payload so you can inspect what is being sent
            console.log("TOWALLET SEND PAYLOAD:", JSON.stringify(txPayload, null, 2));

            // guard: if receiver_acc absent, fail early (we must send it)
            if (!txPayload.receiver_acc) {
              showError('Transaction failed: Missing receiver_acc in pending transaction. Please retry.');
              return;
            }

            try {
              const execRes = await fetch(TOWALLET_SEND, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify(txPayload)
              });
              const execJson = await execRes.json().catch(()=>null);

              if (execRes.ok && execJson && (execJson.status === 'success' || execJson.success === true)) {
                // clear pending and set last_tx_success for towallet page to show popup
                clearPending();
                sessionStorage.setItem('last_tx_success', JSON.stringify({
                  type: 'success',
                  message: execJson.message || 'Transfer successful',
                  amount: pending.amount,
                  orderAmount: pending.amount,
                  datetime: new Date().toLocaleString(),
                  sender: pending.sender_name || (user && (user.username || user.name)) || 'You',
                  senderAccount: pending.sender_account || (user && (user.account_number || '')) || '-',
                  bankName: pending.receiver_bank_name || txPayload.receiver_bank || 'PAYME',
                  recipient: pending.receiver_name || pending.recipient || pending.receiver || pending.recipientAccount || txPayload.receiver_acc,
                  recipientAccount: pending.recipientAccount || txPayload.receiver_acc,
                  txnNo: execJson.transaction_id || execJson.txn_id || execJson.reference || '-',
                  statusText: 'Successful'
                }));

                // redirect back to towallet page (or returnUrl)
                const returnUrl = getReturnUrl();
                window.location.href = returnUrl;
                return;
              } else {
                // pass backend's message if present
                const reason = (execJson && (execJson.message || execJson.error || execJson.msg)) ? (execJson.message || execJson.error || execJson.msg) : `HTTP ${execRes.status}`;
                showError('Transaction failed: ' + reason);
                return;
              }
            } catch(execErr){
              console.error('execution error', execErr);
              showError('Network error while executing transaction.');
              return;
            }
          } else {
            // Airtime/data default flow - unchanged
            const txPayload = {
              phone: pending.phone || pending.recipient,
              network: pending.network,
              amount: pending.amount,
              recipient: pending.recipient
            };

            try {
              const execRes = await fetch(BUY_AIRTIME, {
                method: 'POST',
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(txPayload)
              });
              const execJson = await execRes.json().catch(()=>null);

              if (execRes.ok && execJson && execJson.status === 'success') {
                clearPending();
                sessionStorage.setItem('last_tx_success', JSON.stringify({
                  message: execJson.message || 'Airtime purchased successfully',
                  amount: pending.amount,
                  network: pending.network,
                  recipient: pending.recipient || pending.phone,
                  datetime: new Date().toISOString(),
                  statusText: 'Successful'
                }));

                const returnUrl = getReturnUrl();
                window.location.href = returnUrl;
                return;
              } else {
                const reason = execJson && (execJson.message || execJson.error) ? (execJson.message || execJson.error) : `HTTP ${execRes.status}`;
                showError('Transaction failed: ' + reason);
                return;
              }
            } catch(execErr){
              console.error('execution error', execErr);
              showError('Network error while executing transaction.');
              return;
            }
          }

        } else {
          // invalid PIN -> increment attempts and maybe lock
          lockInfo = loadLockInfo();
          incrementFailedAndMaybeLock();
          current = '';
          refreshDots();
          return;
        }
      } catch(err){
        console.error('verify error', err);
        showError('Network error while verifying PIN');
        return;
      }
    });

    (function init(){
      const user = getStoredUser();
      // setup lockKey
      const acctId = user ? ((user.account_number || user.accountNumber) || user.phone) : 'anonymous';
      lockKey = getLockKeyForAccount(acctId);
      lockInfo = loadLockInfo();

      // if locked and lock time still in future -> disable UI and show remaining
      if (isLocked()) {
        disableKeypad();
        const until = new Date(lockInfo.lockedUntil);
        message.textContent = `Too many failed attempts. Try again in ${formatRemaining(until - new Date())}.`;
        setLockCountdown();
      } else {
        if (lockInfo.lockedUntil) {
          clearLockInfo();
        }
      }

      // If there is no pending (session or url) show friendly error and keep disabled
      if (!pending) {
        const params = new URLSearchParams(window.location.search);
        const debugList = [];
        if (!params.get('phone') && !params.get('recipient')) debugList.push('phone/recipient');
        if (!params.get('network')) debugList.push('network');
        if (!params.get('amount')) debugList.push('amount');
        if (!params.get('receiver_acc') && !sessionStorage.getItem('pending_tx')) debugList.push('receiver_acc (for towallet)');
        if (debugList.length) {
          message.textContent = 'Missing fields: ' + debugList.join(', ') + '. Please return and retry.';
        } else {
          message.textContent = 'No pending transaction found. Go back and try again.';
        }
        submitBtn.disabled = true;
      } else {
        updateMessageFromPending();
        refreshDots();
      }
    })();

    // ensure keys are focusable for keyboard accessibility
    document.querySelectorAll('.key').forEach(k => { k.setAttribute('tabindex', '0'); });

    // helper to map bank code to name using localStorage banks if available
    function getReturnBankName(code){
      try {
        const raw = localStorage.getItem('banks') || localStorage.getItem('bankList') || null;
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          const found = parsed.find(b => String(b.code) === String(code));
          return found ? found.name : null;
        }
        if (typeof parsed === 'object') {
          if (parsed[code]) return parsed[code];
        }
      } catch(e){}
      return null;
    }

  })();
</script>
</body>
</html>

