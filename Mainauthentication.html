<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PAYME — Confirm Transaction (PIN)</title>
  <style>
    :root{ --bg:#fafafa; --card:#fff; --accent:#00a884; --danger:#d9534f; --muted:#666; }
    html,body{height:100%;margin:0;font-family:system-ui,Arial;background:var(--bg);display:flex;align-items:center;justify-content:center}
    .card{width:100%;max-width:420px;background:var(--card);border-radius:12px;padding:20px;box-shadow:0 12px 40px rgba(0,0,0,0.08)}
    h2{margin:0 0 6px}
    p{color:var(--muted);margin:0 0 12px}
    .pin-dots{display:flex;gap:10px;justify-content:center;margin:18px 0}
    .dot{width:56px;height:56px;border-radius:8px;border:1px solid #eee;display:flex;align-items:center;justify-content:center;font-size:24px;background:#fff}
    .keypad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .key{height:64px;border-radius:10px;background:#fff;border:1px solid #eee;display:flex;align-items:center;justify-content:center;font-size:20px;cursor:pointer;user-select:none}
    .row{display:flex;gap:8px;margin-top:12px}
    .btn{flex:1;padding:10px;border-radius:10px;border:0;cursor:pointer}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-outline{background:#fff;border:1px solid #ddd}
    .danger{color:var(--danger);margin-top:8px;text-align:center;display:none}
    .note{color:#666;font-size:13px;text-align:center;margin-top:8px}
    .hidden{display:none}
    .key.disabled { opacity:0.6; pointer-events:none; }
  </style>
</head>
<body>
  <div class="card" role="dialog" aria-modal="true">
    <h2>Enter your 4-digit PIN</h2>
    <p>Confirm this transaction with the PIN linked to your account.</p><div class="pin-dots" id="pinDots" aria-hidden="false">
  <div class="dot" data-index="0" aria-hidden="true"></div>
  <div class="dot" data-index="1" aria-hidden="true"></div>
  <div class="dot" data-index="2" aria-hidden="true"></div>
  <div class="dot" data-index="3" aria-hidden="true"></div>
</div>

<div id="message" class="note">Type your 4-digit PIN</div>
<div id="error" class="danger" role="alert"></div>

<div class="keypad" id="keypad" aria-label="PIN keypad" style="margin-top:14px">
  <div class="key" role="button" tabindex="0">1</div><div class="key" role="button" tabindex="0">2</div><div class="key" role="button" tabindex="0">3</div>
  <div class="key" role="button" tabindex="0">4</div><div class="key" role="button" tabindex="0">5</div><div class="key" role="button" tabindex="0">6</div>
  <div class="key" role="button" tabindex="0">7</div><div class="key" role="button" tabindex="0">8</div><div class="key" role="button" tabindex="0">9</div>
  <div class="key" id="blank" aria-hidden="true"></div><div class="key" role="button" tabindex="0">0</div><div class="key" id="back" role="button" tabindex="0" aria-label="Backspace">⌫</div>
</div>

<div class="row" style="margin-top:18px">
  <button id="cancelBtn" class="btn btn-outline">Cancel</button>
  <button id="submitBtn" class="btn btn-primary" disabled>Verify & Pay</button>
</div>

  </div><script>
  (function(){
    // Configuration
    const API_BASE = "https://payme-update.onrender.com";
    const TOWALLET_SEND = API_BASE + "/towallet/send_money"; // change if your route differs
    const BUY_AIRTIME = API_BASE + "/buy_airtime"; // change if your route differs

    // DOM
    const keypad = document.getElementById('keypad');
    const pinDots = Array.from(document.querySelectorAll('.dot'));
    const message = document.getElementById('message');
    const errorEl = document.getElementById('error');
    const submitBtn = document.getElementById('submitBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    // Lock config
    const LOCK_THRESHOLD = 3;               // 3 failed attempts
    const LOCK_DURATION_MS = 4 * 60 * 60 * 1000; // 4 hours

    // Helpers to read storage
    function getStoredUser() {
      const j = localStorage.getItem("loggedInUser") || localStorage.getItem("user");
      try { return j ? JSON.parse(j) : null; } catch(e){ return null; }
    }
    function getPendingFromSession() { try { const p = sessionStorage.getItem('pending_tx'); return p ? JSON.parse(p) : null; } catch(e){ return null; } }
    function clearPending() { try { sessionStorage.removeItem('pending_tx'); } catch(e){} }

    // Accept pending from URL for legacy flows
    function getPendingFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const phone = params.get('phone') || params.get('recipient') || params.get('to') || null;
      const network = params.get('network') || params.get('operator') || null;
      const amount = params.get('amount') || params.get('amt') || null;
      const receiver_acc = params.get('receiver_acc') || params.get('receiver') || params.get('recipient_acc') || params.get('recipientAccount') || null;
      const product = params.get('product') || (network ? 'airtime' : null);
      if (!phone && !network && !amount && !receiver_acc) return null;
      return {
        product,
        phone,
        recipient: params.get('recipient_name') || params.get('receiver_name') || params.get('recipient') || null,
        receiver_acc,
        recipientAccount: receiver_acc,
        network,
        amount,
        created_at: new Date().toISOString()
      };
    }

    // Main pending object
    let pending = getPendingFromSession() || getPendingFromUrl();

    // PIN input state and lock storage
    let current = '';
    let lockInfo = null;
    let lockKey = null;
    let countdownInterval = null;

    function getLockKeyForAccount(accountId){ return `pin_lock_${accountId || 'anonymous'}`; }
    function loadLockInfo(){ try { const raw = localStorage.getItem(lockKey); if (!raw) return { failedAttempts: 0, lockedUntil: null }; const parsed = JSON.parse(raw); return { failedAttempts: parsed.failedAttempts || 0, lockedUntil: parsed.lockedUntil || null }; } catch(e){ return { failedAttempts: 0, lockedUntil: null }; } }
    function saveLockInfo(info){ try { localStorage.setItem(lockKey, JSON.stringify(info)); } catch(e){ console.warn('saveLockInfo failed', e); } lockInfo = info; }
    function clearLockInfo(){ try { localStorage.removeItem(lockKey); } catch(e){} lockInfo = { failedAttempts:0, lockedUntil: null }; enableKeypad(); updateMessageFromPending(); if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; } }
    function isLocked(){ if (!lockInfo || !lockInfo.lockedUntil) return false; try { return (new Date(lockInfo.lockedUntil) > new Date()); } catch(e){ return false; } }
    function formatRemaining(ms){ if (ms <= 0) return '0s'; const totalSec = Math.floor(ms/1000); const hrs = Math.floor(totalSec / 3600); const mins = Math.floor((totalSec % 3600) / 60); const secs = totalSec % 60; if (hrs > 0) return `${hrs}h ${mins}m`; if (mins > 0) return `${mins}m ${secs}s`; return `${secs}s`; }
    function disableKeypad(){ keypad.querySelectorAll('.key').forEach(k => k.classList.add('disabled')); submitBtn.disabled = true; }
    function enableKeypad(){ keypad.querySelectorAll('.key').forEach(k => k.classList.remove('disabled')); submitBtn.disabled = (current.length !== 4); }
    function setLockCountdown(){ if (!lockInfo || !lockInfo.lockedUntil) return; if (countdownInterval) clearInterval(countdownInterval); countdownInterval = setInterval(()=> { const until = new Date(lockInfo.lockedUntil); const msLeft = until - new Date(); if (msLeft <= 0) { clearInterval(countdownInterval); countdownInterval = null; clearLockInfo(); return; } message.textContent = `Too many failed attempts. Try again in ${formatRemaining(msLeft)}.`; }, 1000); }

    function refreshDots(){ pinDots.forEach((d,i)=> { const ch = current[i] || ''; d.textContent = ch ? '•' : ''; d.classList.toggle('filled', !!ch); }); submitBtn.disabled = (current.length !== 4) || isLocked(); }
    function showError(msg){ errorEl.style.display='block'; errorEl.textContent = msg; }
    function clearError(){ errorEl.style.display='none'; errorEl.textContent=''; }

    function updateMessageFromPending(){
      if (!pending) {
        message.textContent = 'No pending transaction — go back and try again.';
        submitBtn.disabled = true;
        return;
      }
      if (pending.product === 'towallet' || pending.receiver_acc) {
        const recv = pending.receiver_acc || pending.recipient || pending.phone || '-';
        const bank = pending.receiver_bank_name || pending.receiver_bank || pending.bankName || '';
        message.textContent = `Confirm ₦${Number(pending.amount || 0).toLocaleString()} to ${recv}${bank ? ' ('+bank+')' : ''}`;
        return;
      }
      const recipient = pending.recipient || pending.phone || '-';
      const network = pending.network || '-';
      message.textContent = `Confirm ₦${Number(pending.amount || 0).toLocaleString()} to ${recipient} (${network})`;
    }

    function incrementFailedAndMaybeLock(){
      const now = new Date();
      lockInfo.failedAttempts = (lockInfo.failedAttempts || 0) + 1;
      if (lockInfo.failedAttempts >= LOCK_THRESHOLD) {
        const until = new Date(now.getTime() + LOCK_DURATION_MS);
        lockInfo.lockedUntil = until.toISOString();
        saveLockInfo(lockInfo);
        disableKeypad();
        message.textContent = `Too many failed attempts. Transactions suspended until ${until.toLocaleString()}`;
        setLockCountdown();
      } else {
        saveLockInfo(lockInfo);
        const left = LOCK_THRESHOLD - lockInfo.failedAttempts;
        showError(`Invalid PIN. ${left} attempt${left>1?'s':''} left before lock.`);
      }
    }

    // keypad wiring
    keypad.addEventListener('click', ev=>{ const k = ev.target; if (!k.classList.contains('key')) return; if (isLocked()) return; handleKey(k); });
    keypad.addEventListener('keydown', ev=>{ if (ev.key === 'Enter' || ev.key === ' ') { const k = document.activeElement; if (k && k.classList.contains('key')) { ev.preventDefault(); if (isLocked()) return; handleKey(k); } } });
    function handleKey(k){ if (k.id === 'back') { current = current.slice(0,-1); clearError(); refreshDots(); return; } if (k.id === 'blank') return; if (current.length >= 4) return; current += (k.textContent || '').trim(); refreshDots(); }

    cancelBtn.addEventListener('click', ()=> { if (pending && pending.product === 'towallet') window.location.href = 'towallet.html'; else window.location.href = 'airtime.html'; });

    function getReturnUrl() {
      try {
        const explicit = sessionStorage.getItem('return_to');
        if (explicit) return explicit;
        if (document.referrer && document.referrer !== '') return document.referrer;
        if (pending && pending.product) {
          if (pending.product === 'data') return 'data.html';
          if (pending.product === 'airtime') return 'airtime.html';
          if (pending.product === 'towallet') return 'towallet.html';
        }
      } catch(e){}
      return 'airtime.html';
    }

    // --- Network helpers: execute flows ---
    async function executeTowallet(pending, user) {
      if (!pending) return { ok:false, error:'No pending' };
      if (!user) return { ok:false, error:'No logged-in user' };

      const senderPhone = pending.sender_phone || pending.phone || user.phone || null;
      const receiverAccVal = pending.receiver_acc || pending.recipientAccount || pending.recipient || null;
      if (!receiverAccVal) return { ok:false, error:'Missing receiver_acc in pending transaction.' };

      const txPayload = {
        sender_phone: senderPhone,
        sender_account: pending.senderAccount || (user.account_number || user.accountNumber) || undefined,
        receiver_acc: receiverAccVal,
        recipient: pending.recipient || pending.receiver_name || undefined,
        amount: pending.amount,
        amount_kobo: pending.amount_kobo,
        receiver_bank: pending.receiver_bank || pending.receiver_bank_name || 'PAYME',
        product: pending.product || 'towallet',
        reference: pending.reference || pending.idempotency_key || undefined
      };

      const headers = { 'Content-Type':'application/json', 'Accept':'application/json', 'Idempotency-Key': pending.idempotency_key || pending.reference || '' };
      // If you use token auth, add Authorization here
      // headers['Authorization'] = 'Bearer ' + (localStorage.getItem('authToken') || '');

      try {
        const execRes = await fetch(TOWALLET_SEND, { method:'POST', credentials:'include', headers, body: JSON.stringify(txPayload) });
        const execJson = await execRes.json().catch(()=>null);
        if (!execRes.ok) {
          const reason = (execJson && (execJson.message || execJson.error || execJson.msg)) || `HTTP ${execRes.status}`;
          return { ok:false, error: reason, detail: execJson };
        }
        if (!(execJson && (execJson.success === true || execJson.status === 'success' || execJson.code === 200))) {
          const reason = (execJson && (execJson.message || execJson.error || execJson.msg)) || 'Unknown server response';
          return { ok:false, error: reason, detail: execJson };
        }

        const newBalance = execJson.new_balance ?? execJson.balance ?? execJson.updated_balance ?? execJson.account_balance ?? null;
        const successPayload = {
          type: 'success',
          message: execJson.message || 'Transfer successful',
          amount: pending.amount,
          orderAmount: pending.amount,
          datetime: new Date().toLocaleString(),
          sender: pending.sender || (user.username || user.name) || 'You',
          senderAccount: pending.senderAccount || (user.account_number || user.accountNumber) || '-',
          bankName: txPayload.receiver_bank || 'PAYME',
          recipient: pending.recipient || txPayload.receiver_acc,
          recipientAccount: pending.recipientAccount || txPayload.receiver_acc,
          txnNo: execJson.transaction_id || execJson.txn_id || execJson.reference || execJson.txnNo || '-',
          statusText: 'Successful',
          raw: execJson
        };

        sessionStorage.setItem('last_tx_success', JSON.stringify(successPayload));

        if (newBalance !== null && !isNaN(Number(newBalance))) {
          try { localStorage.setItem('balance', String(newBalance)); } catch(e){}
          try { const stored = localStorage.getItem('loggedInUser'); if (stored) { const u = JSON.parse(stored); u.balance = Number(newBalance); localStorage.setItem('loggedInUser', JSON.stringify(u)); } } catch(e){}
          try { const stored2 = localStorage.getItem('user'); if (stored2) { const u2 = JSON.parse(stored2); u2.balance = Number(newBalance); localStorage.setItem('user', JSON.stringify(u2)); } } catch(e){}

          // Broadcast update
          try { const bc = new BroadcastChannel('payme_channel'); bc.postMessage({ type:'balance_update', balance: Number(newBalance), reference: successPayload.txnNo }); bc.close(); }
          catch(e) { try { localStorage.setItem('payme_balance_update', JSON.stringify({ balance: Number(newBalance), ts: Date.now(), reference: successPayload.txnNo })); } catch(e){} }
        }

        sessionStorage.removeItem('pending_tx');
        return { ok:true, payload: successPayload, raw: execJson };
      } catch (err) { console.error('executeTowallet error', err); return { ok:false, error: 'Network error while executing transaction', detail: String(err) }; }
    }

    async function executeAirtime(pending, user) {
      const txPayload = { phone: pending.phone || pending.recipient, network: pending.network, amount: pending.amount, recipient: pending.recipient };
      try {
        const execRes = await fetch(BUY_AIRTIME, { method:'POST', credentials:'include', headers:{'Content-Type':'application/json'}, body: JSON.stringify(txPayload) });
        const execJson = await execRes.json().catch(()=>null);
        if (!execRes.ok || !(execJson && (execJson.status === 'success' || execJson.success === true))) {
          const reason = (execJson && (execJson.message || execJson.error)) || `HTTP ${execRes.status}`;
          return { ok:false, error: reason, detail: execJson };
        }
        const successPayload = { message: execJson.message || 'Airtime purchased successfully', amount: pending.amount, network: pending.network, recipient: pending.recipient || pending.phone, datetime: new Date().toISOString(), statusText: 'Successful', raw: execJson };
        sessionStorage.setItem('last_tx_success', JSON.stringify(successPayload));
        sessionStorage.removeItem('pending_tx');
        return { ok:true, payload: successPayload, raw: execJson };
      } catch (err) { console.error('executeAirtime error', err); return { ok:false, error:'Network error while executing airtime', detail: String(err) }; }
    }

    // Submit flow: verify PIN then execute
    submitBtn.addEventListener('click', async ()=>{
      clearError();
      if (isLocked()) { const until = lockInfo && lockInfo.lockedUntil ? new Date(lockInfo.lockedUntil) : null; if (until) showError(`Too many failed attempts. Try again in ${formatRemaining(until - new Date())}.`); else showError('Too many failed attempts. Try later.'); return; }
      if (!pending) { showError('No pending transaction found. Go back and try again.'); return; }
      const user = getStoredUser();
      if (!user || !(user.account_number || user.accountNumber || user.phone)) { showError('You must be logged in. Please log in and try again.'); return; }

      // lock key setup
      const acctId = (user.account_number || user.accountNumber) || user.phone;
      if (!lockKey) lockKey = getLockKeyForAccount(acctId);
      if (!lockInfo) lockInfo = loadLockInfo();

      // verify PIN with backend
      const accountNumber = (user.account_number || user.accountNumber || '').toString();
      const payload = { account_number: accountNumber, pin: current };
      try {
        submitBtn.disabled = true; submitBtn.textContent = 'Verifying...';
        const res = await fetch(`${API_BASE}/api/pin/verify`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const j = await res.json().catch(()=>({ success:false, message: 'Invalid server response' }));

        if (res.ok && j.success) {
          // reset lock info
          saveLockInfo({ failedAttempts: 0, lockedUntil: null });

          // execute based on product
          let result;
          if (pending.product === 'towallet' || pending.receiver_acc) {
            result = await executeTowallet(pending, user);
          } else {
            result = await executeAirtime(pending, user);
          }

          if (result.ok) {
            // redirect back to the page which will read last_tx_success and show modal
            const returnUrl = getReturnUrl();
            window.location.href = returnUrl;
            return;
          } else {
            showError('Transaction failed: ' + (result.error || 'Unknown error'));
            console.error('execution error detail', result.detail || result);
            // do not increment lock counter here — PIN was valid
          }

        } else {
                   // invalid PIN -> increment attempts and maybe lock
          lockInfo = loadLockInfo();
          incrementFailedAndMaybeLock();
          current = '';
          refreshDots();
          return;
        }
      } catch(err){ console.error('verify error', err); showError('Network error while verifying PIN'); return; }
      finally { submitBtn.disabled = false; submitBtn.textContent = 'Verify & Pay'; }
    });

    (function init(){
      const user = getStoredUser();
      const acctId = user ? ((user.account_number || user.accountNumber) || user.phone) : 'anonymous';
      lockKey = getLockKeyForAccount(acctId);
      lockInfo = loadLockInfo();

      if (isLocked()) { disableKeypad(); const until = new Date(lockInfo.lockedUntil); message.textContent = `Too many failed attempts. Try again in ${formatRemaining(until - new Date())}.`; setLockCountdown(); } else { if (lockInfo.lockedUntil) clearLockInfo(); }

      if (!pending) {
        const params = new URLSearchParams(window.location.search);
        const debugList = [];
        if (!params.get('phone') && !params.get('recipient')) debugList.push('phone/recipient');
        if (!params.get('network')) debugList.push('network');
        if (!params.get('amount')) debugList.push('amount');
        if (!params.get('receiver_acc') && !sessionStorage.getItem('pending_tx')) debugList.push('receiver_acc (for towallet)');
        if (debugList.length) { message.textContent = 'Missing fields: ' + debugList.join(', ') + '. Please return and retry.'; } else { message.textContent = 'No pending transaction found. Go back and try again.'; }
        submitBtn.disabled = true;
      } else {
        updateMessageFromPending(); refreshDots();
      }
    })();

    // accessibility: ensure keys are focusable
    document.querySelectorAll('.key').forEach(k => { k.setAttribute('tabindex', '0'); });

  })();
</script>
</body>
</html>