<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PAYME — Confirm Transaction (PIN)</title>
  <style>
    :root{ --bg:#fafafa; --card:#fff; --accent:#00a884; --danger:#d9534f; --muted:#666; }
    html,body{height:100%;margin:0;font-family:system-ui,Arial;background:var(--bg);display:flex;align-items:center;justify-content:center}
    .card{width:100%;max-width:420px;background:var(--card);border-radius:12px;padding:20px;box-shadow:0 12px 40px rgba(0,0,0,0.08)}
    h2{margin:0 0 6px}
    p{color:var(--muted);margin:0 0 12px}
    .pin-dots{display:flex;gap:10px;justify-content:center;margin:18px 0}
    .dot{width:56px;height:56px;border-radius:8px;border:1px solid #eee;display:flex;align-items:center;justify-content:center;font-size:24px;background:#fff}
    .keypad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .key{height:64px;border-radius:10px;background:#fff;border:1px solid #eee;display:flex;align-items:center;justify-content:center;font-size:20px;cursor:pointer;user-select:none}
    .row{display:flex;gap:8px;margin-top:12px}
    .btn{flex:1;padding:10px;border-radius:10px;border:0;cursor:pointer}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-outline{background:#fff;border:1px solid #ddd}
    .danger{color:var(--danger);margin-top:8px;text-align:center;display:none}
    .note{color:#666;font-size:13px;text-align:center;margin-top:8px}
    .hidden{display:none}
    .key.disabled { opacity:0.6; pointer-events:none; }
  </style>
</head>
<body>
  <div class="card" role="dialog" aria-modal="true">
    <h2>Enter your 4-digit PIN</h2>
    <p>Confirm this transaction with the PIN linked to your account.</p>

    <div class="pin-dots" id="pinDots" aria-hidden="false">
      <div class="dot" data-index="0" aria-hidden="true"></div>
      <div class="dot" data-index="1" aria-hidden="true"></div>
      <div class="dot" data-index="2" aria-hidden="true"></div>
      <div class="dot" data-index="3" aria-hidden="true"></div>
    </div>

    <div id="message" class="note">Type your 4-digit PIN</div>
    <div id="error" class="danger" role="alert"></div>

    <div class="keypad" id="keypad" aria-label="PIN keypad" style="margin-top:14px">
      <div class="key" role="button" tabindex="0">1</div><div class="key" role="button" tabindex="0">2</div><div class="key" role="button" tabindex="0">3</div>
      <div class="key" role="button" tabindex="0">4</div><div class="key" role="button" tabindex="0">5</div><div class="key" role="button" tabindex="0">6</div>
      <div class="key" role="button" tabindex="0">7</div><div class="key" role="button" tabindex="0">8</div><div class="key" role="button" tabindex="0">9</div>
      <div class="key" id="blank" aria-hidden="true"></div><div class="key" role="button" tabindex="0">0</div><div class="key" id="back" role="button" tabindex="0" aria-label="Backspace">⌫</div>
    </div>

    <div class="row" style="margin-top:18px">
      <button id="cancelBtn" class="btn btn-outline">Cancel</button>
      <button id="submitBtn" class="btn btn-primary" disabled>Verify & Pay</button>
    </div>
  </div>

<script>
  (function(){
    const API_BASE = "https://payme-update.onrender.com";
    const keypad = document.getElementById('keypad');
    const pinDots = Array.from(document.querySelectorAll('.dot'));
    const message = document.getElementById('message');
    const errorEl = document.getElementById('error');
    const submitBtn = document.getElementById('submitBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    const LOCK_THRESHOLD = 3;               // 3 failed attempts
    const LOCK_DURATION_MS = 4 * 60 * 60 * 1000; // 4 hours

    function getStoredUser() {
      const j = localStorage.getItem("loggedInUser") || localStorage.getItem("user");
      try { return j ? JSON.parse(j) : null; } catch(e){ return null; }
    }

    function getPending() {
      try { const p = sessionStorage.getItem('pending_tx'); return p ? JSON.parse(p) : null; } catch(e){ return null; }
    }
    function clearPending() {
      try { sessionStorage.removeItem('pending_tx'); } catch(e){}
    }

    let current = '';
    let lockInfo = null;   // { failedAttempts, lockedUntilISO }
    let lockKey = null;
    let lockTimer = null;
    let countdownInterval = null;

    function getLockKeyForAccount(accountId){
      // accountId: prefer account number, fallback to phone if needed
      return `pin_lock_${accountId || 'anonymous'}`;
    }
    function loadLockInfo(){
      try {
        const raw = localStorage.getItem(lockKey);
        if (!raw) return { failedAttempts: 0, lockedUntil: null };
        const parsed = JSON.parse(raw);
        // normalize
        return { failedAttempts: parsed.failedAttempts || 0, lockedUntil: parsed.lockedUntil || null };
      } catch(e){
        return { failedAttempts: 0, lockedUntil: null };
      }
    }
    function saveLockInfo(info){
      try {
        localStorage.setItem(lockKey, JSON.stringify(info));
      } catch(e){ console.warn('saveLockInfo failed', e); }
      lockInfo = info;
    }
    function clearLockInfo(){
      try { localStorage.removeItem(lockKey); } catch(e){}
      lockInfo = { failedAttempts:0, lockedUntil: null };
      enableKeypad();
      updateMessageFromPending();
      if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
    }

    function isLocked(){
      if (!lockInfo || !lockInfo.lockedUntil) return false;
      try {
        const until = new Date(lockInfo.lockedUntil);
        return until > new Date();
      } catch(e){ return false; }
    }

    function formatRemaining(ms){
      if (ms <= 0) return '0s';
      const totalSec = Math.floor(ms/1000);
      const hrs = Math.floor(totalSec / 3600);
      const mins = Math.floor((totalSec % 3600) / 60);
      const secs = totalSec % 60;
      if (hrs > 0) return `${hrs}h ${mins}m`;
      if (mins > 0) return `${mins}m ${secs}s`;
      return `${secs}s`;
    }

    function disableKeypad(){
      keypad.querySelectorAll('.key').forEach(k => k.classList.add('disabled'));
      submitBtn.disabled = true;
    }
    function enableKeypad(){
      keypad.querySelectorAll('.key').forEach(k => k.classList.remove('disabled'));
      submitBtn.disabled = (current.length !== 4);
    }

    function setLockCountdown(){
      if (!lockInfo || !lockInfo.lockedUntil) return;
      if (countdownInterval) clearInterval(countdownInterval);
      countdownInterval = setInterval(() => {
        const until = new Date(lockInfo.lockedUntil);
        const msLeft = until - new Date();
        if (msLeft <= 0) {
          clearInterval(countdownInterval);
          countdownInterval = null;
          clearLockInfo();
          return;
        }
        message.textContent = `Too many failed attempts. Try again in ${formatRemaining(msLeft)}.`;
      }, 1000);
    }

    function refreshDots(){
      pinDots.forEach((d,i)=>{
        const ch = current[i] || '';
        d.textContent = ch ? '•' : '';
        d.classList.toggle('filled', !!ch);
      });
      submitBtn.disabled = (current.length !== 4) || isLocked();
    }

    function showError(msg){
      errorEl.style.display='block';
      errorEl.textContent=msg;
    }
    function clearError(){ errorEl.style.display='none'; errorEl.textContent=''; }

    function updateMessageFromPending(){
      const pending = getPending();
      if (!pending) {
        message.textContent = 'No pending transaction — go back and try again.';
        submitBtn.disabled = true;
      } else {
        message.textContent = `Confirm ₦${Number(pending.amount).toLocaleString()} to ${pending.recipient} (${pending.network})`;
      }
    }

    function incrementFailedAndMaybeLock(){
      const now = new Date();
      lockInfo.failedAttempts = (lockInfo.failedAttempts || 0) + 1;
      if (lockInfo.failedAttempts >= LOCK_THRESHOLD) {
        const until = new Date(now.getTime() + LOCK_DURATION_MS);
        lockInfo.lockedUntil = until.toISOString();
        saveLockInfo(lockInfo);
        disableKeypad();
        // show remaining time
        message.textContent = `Too many failed attempts. Transactions suspended until ${until.toLocaleString()}`;
        // start countdown updates
        setLockCountdown();
      } else {
        saveLockInfo(lockInfo);
        const left = LOCK_THRESHOLD - lockInfo.failedAttempts;
        showError(`Invalid PIN. ${left} attempt${left>1?'s':''} left before lock.`);
      }
    }

    keypad.addEventListener('click', ev=>{
      const k = ev.target;
      if (!k.classList.contains('key')) return;
      // ignore input if locked
      if (isLocked()) return;
      handleKey(k);
    });
    keypad.addEventListener('keydown', ev=>{
      if (ev.key === 'Enter' || ev.key === ' ') {
        const k = document.activeElement;
        if (k && k.classList.contains('key')) {
          ev.preventDefault();
          if (isLocked()) return;
          handleKey(k);
        }
      }
    });
    function handleKey(k){
      if (k.id === 'back') { current = current.slice(0,-1); clearError(); refreshDots(); return; }
      if (k.id === 'blank') return;
      if (current.length >= 4) return;
      current += (k.textContent || '').trim();
      refreshDots();
    }

    cancelBtn.addEventListener('click', ()=>{
      // redirect back to airtime page
      window.location.href = 'airtime.html';
    });

    submitBtn.addEventListener('click', async ()=>{
      clearError();
      if (isLocked()) {
        // locked — display message
        const until = lockInfo && lockInfo.lockedUntil ? new Date(lockInfo.lockedUntil) : null;
        if (until) {
          showError(`Too many failed attempts. Try again in ${formatRemaining(until - new Date())}.`);
        } else {
          showError('Too many failed attempts. Try later.');
        }
        return;
      }

      const pending = getPending();
      if (!pending) {
        showError('No pending transaction found. Go back and try again.');
        return;
      }

      const user = getStoredUser();
      if (!user || !(user.account_number || user.accountNumber || user.phone)) {
        showError('You must be logged in. Please log in and try again.');
        return;
      }

      // determine lock key (account_number preferred, fallback to phone)
      const acctId = (user.account_number || user.accountNumber) || user.phone;
      if (!lockKey) lockKey = getLockKeyForAccount(acctId);
      if (!lockInfo) lockInfo = loadLockInfo();

      const accountNumber = (user.account_number || user.accountNumber || '').toString();
      const payload = { account_number: accountNumber, pin: current };

      try {
        const res = await fetch(`${API_BASE}/api/pin/verify`, {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const j = await res.json().catch(()=>({ success:false, message: 'Invalid server response' }));

        if (res.ok && j.success) {
          // success -> reset lock info
          saveLockInfo({ failedAttempts: 0, lockedUntil: null });
          // PIN ok -> execute pending transaction
          const txPayload = {
            phone: pending.phone,
            network: pending.network,
            amount: pending.amount,
            recipient: pending.recipient,
            product: pending.product || 'airtime'
          };

          try {
            const execRes = await fetch(`${API_BASE}/buy_airtime`, {
              method: 'POST',
              credentials: 'include',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(txPayload)
            });
            const execJson = await execRes.json().catch(()=>null);

            if (execRes.ok && execJson && execJson.status === 'success') {
              clearPending();
              sessionStorage.setItem('last_tx_success', JSON.stringify({
                message: execJson.message || 'Airtime purchased successfully',
                amount: pending.amount,
                network: pending.network,
                recipient: pending.recipient,
                datetime: new Date().toISOString()
              }));
              // redirect to airtime page after success
              window.location.href = 'airtime.html';
              return;
            } else {
              const reason = execJson && (execJson.message || execJson.error) ? (execJson.message || execJson.error) : `HTTP ${execRes.status}`;
              showError('Transaction failed: ' + reason);
              return;
            }
          } catch(execErr){
            console.error('execution error', execErr);
            showError('Network error while executing transaction.');
            return;
          }

        } else {
          // invalid PIN -> increment attempts and maybe lock
          // load current lockInfo and increment
          if (!lockKey) {
            const acctId2 = (user.account_number || user.accountNumber) || user.phone;
            lockKey = getLockKeyForAccount(acctId2);
          }
          lockInfo = loadLockInfo();
          incrementFailedAndMaybeLock();
          // clear entered PIN and UI dots
          current = '';
          refreshDots();
          return;
        }
      } catch(err){
        console.error('verify error', err);
        showError('Network error while verifying PIN');
        return;
      }
    });

    (function init(){
      const pending = getPending();
      const user = getStoredUser();
      // setup lockKey
      const acctId = user ? ((user.account_number || user.accountNumber) || user.phone) : 'anonymous';
      lockKey = getLockKeyForAccount(acctId);
      lockInfo = loadLockInfo();

      // if locked and lock time still in future -> disable UI and show remaining
      if (isLocked()) {
        disableKeypad();
        const until = new Date(lockInfo.lockedUntil);
        message.textContent = `Too many failed attempts. Try again in ${formatRemaining(until - new Date())}.`;
        setLockCountdown();
      } else {
        // if expired, clear stored lock
        if (lockInfo.lockedUntil) {
          // expired -> clear
          clearLockInfo();
        }
      }

      updateMessageFromPending();
      refreshDots();
    })();

    // ensure keys are focusable for keyboard accessibility
    document.querySelectorAll('.key').forEach(k => { k.setAttribute('tabindex', '0'); });

  })();
</script>
</body>
</html>