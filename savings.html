<!-- savings.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Savings Page</title>
  <style>
  body {
    font-family: Arial, sans-serif;
    background: #f3f3f3;
    margin: 0;
    padding: 0;
  }

  .container {
    width: 90%;
    margin: auto;
    padding: 20px;
  }

  h2 {
    text-align: center;
    color: #333;
  }

  .card {
    background: #fff;
    padding: 20px;
    margin-top: 20px;
    border-radius: 10px;
    box-shadow: 0px 3px 6px rgba(0,0,0,0.1);
  }

  form label {
    display: block;
    margin: 10px 0 5px;
  }

  form input, form select {
    width: 100%;
    padding: 10px;
    margin-bottom: 15px;
  }

  button {
    background: #28a745;
    color: white;
    padding: 10px;
    border: none;
    width: 100%;
    border-radius: 5px;
    cursor: pointer;
  }

  button:hover {
    background: #218838;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
  }

  table th, table td {
    padding: 10px;
    border: 1px solid #ddd;
    text-align: center;
  }

  .action-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
  }

  .back-btn {
    background: #007bff;
    margin-top: 20px;
  }

  .back-btn:hover {
    background: #0056b3;
  }

  .disabled-btn {
    background: #ccc !important;
    cursor: not-allowed;
  }
  </style>
</head>
<body>
  <div class="container">
    <h2>💰 Savings Dashboard</h2>

    <!-- Create Savings -->
    <div class="card">
      <h3>Create Savings</h3>
      <form id="savingsForm">
        <label>Amount</label>
        <input type="number" id="amount" required>

        <label>Type</label>
        <select id="savingsType">
          <option value="flexible">Flexible</option>
          <option value="fixed">Fixed</option>
        </select>

        <label>Duration</label>
        <select id="duration">
          <option value="7">7 Days</option>
          <option value="30">30 Days</option>
          <option value="60">60 Days</option>
          <option value="180">180 Days</option>
          <option value="365">1 Year</option>
          <option value="730">2 Years</option>
          <option value="1095">3 Years</option>
        </select>

        <button type="submit">Start Saving</button>
      </form>
    </div>

    <!-- Active Savings -->
    <div class="card">
      <h3>Active Savings</h3>
      <table>
        <thead>
          <tr>
            <th>Amount</th>
            <th>Type</th>
            <th>End Date</th>
            <th>Status</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="savingsTable"></tbody>
      </table>
    </div>

    <!-- Back button -->
    <button class="back-btn" onclick="goBack()">⬅ Back to Dashboard</button>
  </div>

  <script>
  (function(){
    // <-- CONFIG: point this to your backend (kept as your deployed Render address)
    const API_BASE = "https://payme-update.onrender.com";

    // map of countdown intervals so we can clear when reloading
    const countdownMap = new Map();

    // read user from localStorage (try both keys used in your app)
    function readStoredUser() {
      const raw = localStorage.getItem("loggedInUser") || localStorage.getItem("user");
      if (!raw) return null;
      try { return JSON.parse(raw); } catch (e) { return null; }
    }

    // persist user object to both keys so other pages see it
    function persistUser(userObj) {
      try {
        localStorage.setItem("loggedInUser", JSON.stringify(userObj));
        localStorage.setItem("user", JSON.stringify(userObj));
      } catch (e) {
        console.warn("Could not persist user to localStorage", e);
      }
    }

    // If login didn't save id, fetch user details by phone to get id and balance
    async function ensureUserHasId(u) {
      if (!u) return null;
      if (u.id) return u;
      if (!u.phone) return null;
      try {
        const res = await fetch(`${API_BASE}/user/${encodeURIComponent(u.phone)}`);
        if (!res.ok) {
          console.warn("Could not fetch user details:", res.status);
          return u;
        }
        const data = await res.json();
        if (data.status === "success" && data.user) {
          const newUser = Object.assign({}, u, data.user);
          persistUser(newUser);
          return newUser;
        }
        return u;
      } catch (err) {
        console.warn("Network error while fetching user details:", err);
        return u;
      }
    }

    // safe parse number helpers
    function toFloat(v) {
      const n = parseFloat(v);
      return isNaN(n) ? 0 : n;
    }
    function toInt(v) {
      const n = parseInt(v, 10);
      return isNaN(n) ? 0 : n;
    }

    // utility to update stored balance from backend
    async function refreshStoredBalance(user) {
      if (!user || !user.phone) return;
      try {
        const res = await fetch(`${API_BASE}/balance/${encodeURIComponent(user.phone)}`);
        if (!res.ok) return;
        const d = await res.json();
        if (typeof d.balance !== "undefined") {
          user.balance = Number(d.balance);
          persistUser(user);
        }
      } catch (err) {
        // ignore
      }
    }

    // Clear countdown intervals
    function clearCountdowns() {
      for (const id of countdownMap.keys()) {
        clearInterval(countdownMap.get(id));
      }
      countdownMap.clear();
    }

    // Load savings list for the current user (uses user.id)
    async function loadSavings(user) {
      if (!user || !user.id) {
        console.error("loadSavings called without user id");
        return;
      }

      clearCountdowns();

      const table = document.getElementById("savingsTable");
      table.innerHTML = `<tr><td colspan="5">Loading...</td></tr>`;

      try {
        const res = await fetch(`${API_BASE}/savings/list/${user.id}`);
        const json = await res.json();

        // backend returns { status: "success", savings: [...] }
        const rows = (json && json.savings) ? json.savings : [];

        // filter out withdrawn items so savings list shows only active ones
        const active = rows.filter(r => (r.status || r.state || "").toLowerCase() !== "withdrawn");

        if (!active.length) {
          table.innerHTML = `<tr><td colspan="5">No savings found</td></tr>`;
          return;
        }

        // render active savings
        table.innerHTML = "";
        active.forEach(s => {
          const type = s.savings_type || s.type || "flexible";
          const endRaw = s.end_date || s.endDate || s.end;
          const endDate = endRaw ? new Date(endRaw) : null;
          const id = s.id;
          const amount = s.amount;

          const now = new Date();
          let statusText = "Active";
          if (endDate && endDate <= now) statusText = "Completed";

          // action: flexible -> withdraw anytime; fixed -> only if matured (our list will have matured removed by sweep,
          // but we also double-check)
          let actionHtml = '';
          if ((s.status || "").toLowerCase() === "withdrawn") {
            actionHtml = `<button class="disabled-btn" disabled>Withdrawn</button>`;
          } else if (type === "flexible") {
            actionHtml = `<button data-id="${id}" class="withdraw-btn">Withdraw</button>`;
          } else if (type === "fixed") {
            // If endDate passed we let button be available (but backend's sweep should already handle)
            if (endDate && endDate <= now) {
              actionHtml = `<button data-id="${id}" class="withdraw-btn">Withdraw</button>`;
            } else {
              actionHtml = `<button class="disabled-btn" disabled>Locked</button>`;
            }
          } else {
            actionHtml = `<button class="disabled-btn" disabled>Locked</button>`;
          }

          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${amount}</td>
            <td>${type}</td>
            <td>${endDate ? endDate.toLocaleString() : "-"}</td>
            <td id="timer-${id}">${statusText}</td>
            <td>
              <div class="action-container">
                ${actionHtml}
              </div>
            </td>
          `;
          table.appendChild(tr);

          // attach click handler for newly inserted withdraw button (if any)
          const btn = tr.querySelector("button.withdraw-btn");
          if (btn) {
            btn.addEventListener("click", async function (ev) {
              const sid = toInt(this.getAttribute("data-id"));
              // disable immediately to prevent double-click
              this.disabled = true;
              this.classList.add("disabled-btn");
              await handleWithdraw(user, sid, amount, type, id);
            });
          }

          // start countdown for the row if not withdrawn
          if ((s.status || "").toLowerCase() !== "withdrawn" && endDate) {
            startCountdownForRow(id, endDate, user);
          }
        });

      } catch (err) {
        console.error("Error loading savings:", err);
        table.innerHTML = `<tr><td colspan="5">Error loading savings</td></tr>`;
      }
    }

    // countdown per row (updates seconds). When reaches zero we call loadSavings to allow backend sweep.
    function startCountdownForRow(id, endDate, user) {
      const timerEl = document.getElementById(`timer-${id}`);
      if (!timerEl) return;

      // clear existing interval for id if present
      if (countdownMap.has(id)) {
        clearInterval(countdownMap.get(id));
        countdownMap.delete(id);
      }

      function update() {
        const now = new Date();
        const distance = new Date(endDate) - now;
        if (distance <= 0) {
          timerEl.innerText = "✅ Completed";
          // clear and refresh list to let backend sweep matured fixed deposits
          if (countdownMap.has(id)) {
            clearInterval(countdownMap.get(id));
            countdownMap.delete(id);
          }
          // small delay to ensure backend time alignment, then reload list (which triggers sweep)
          setTimeout(() => loadSavings(user), 600);
          return;
        }

        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
        const hours = Math.floor((distance / (1000 * 60 * 60)) % 24);
        const mins = Math.floor((distance / (1000 * 60)) % 60);
        const secs = Math.floor((distance / 1000) % 60);
        timerEl.innerText = `${days}d ${hours}h ${mins}m ${secs}s`;
      }

      update();
      const iv = setInterval(update, 1000);
      countdownMap.set(id, iv);
    }

    // withdraw handler: posts to /savings/withdraw with { user_id, savings_id }
    async function handleWithdraw(user, savingsId, amount, type, rowId) {
      if (!user || !user.id) {
        alert("User not ready. Try logging in again.");
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/savings/withdraw`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user_id: user.id, savings_id: savingsId })
        });
        const json = await res.json();

        if (json && json.status === "success") {
          // show immediate feedback on UI: set row to Withdrawn, then reload list shortly (so it's removed)
          const timerEl = document.getElementById(`timer-${savingsId}`);
          if (timerEl) timerEl.innerText = "✅ Withdrawn";

          // replace the button in that row with disabled Withdrawn
          const row = document.querySelector(`button[data-id="${savingsId}"]`);
          if (row) {
            row.disabled = true;
            row.classList.add("disabled-btn");
            row.innerText = "Withdrawn";
          }

          // update stored balance (fetch from backend)
          await refreshStoredBalance(user);

          alert(json.message || `₦${amount} withdrawn and credited to main balance.`);

          // reload list after short delay (backend marks it withdrawn)
          setTimeout(() => loadSavings(user), 800);
        } else {
          const msg = (json && json.message) ? json.message : "Withdrawal failed";
          alert("❌ " + msg);
          // refresh list to reflect real state
          setTimeout(() => loadSavings(user), 500);
        }
      } catch (err) {
        console.error("Withdraw error:", err);
        alert("❌ Withdraw failed (network error)");
        setTimeout(() => loadSavings(user), 500);
      }
    }

    // create savings form submit
    async function handleCreateSavings(user, amount, savingsType, durationDays) {
      if (!user) {
        alert("Please login first");
        return;
      }
      // basic validation
      if (toFloat(amount) <= 0) {
        return alert("Amount must be > 0");
      }
      if (!["flexible","fixed"].includes(savingsType)) {
        return alert("Invalid savings type");
      }
      if (toInt(durationDays) <= 0) {
        return alert("Invalid duration");
      }

      try {
        const payload = {
          user_id: user.id,
          phone: user.phone,
          amount: toFloat(amount),
          savings_type: savingsType,
          duration_days: toInt(durationDays)
        };

        const res = await fetch(`${API_BASE}/savings/create`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const json = await res.json();

        if (json && json.status === "success") {
          // update balance by fetching from server
          await refreshStoredBalance(user);

          alert(json.message || "Savings created");
          // reload savings to show new entry
          setTimeout(() => loadSavings(user), 300);
        } else {
          alert("❌ " + (json.message || "Could not create savings"));
        }
      } catch (err) {
        console.error("Create savings error:", err);
        alert("❌ Create failed (network error)");
      }
    }

    // back button (preserve your original destination)
    function goBack() {
      window.location.href = "paymelogin.html";
    }

    // wires form submit + initial load
    async function init() {
      let stored = readStoredUser();
      if (!stored) {
        alert("Please login first");
        window.location.href = "login.html";
        return;
      }

      // ensure we have an id (login may have saved only phone)
      const user = await ensureUserHasId(stored);

      // guard
      if (!user || !user.id) {
        alert("Could not determine your user id. Please login again.");
        window.location.href = "login.html";
        return;
      }

      // attach form submit
      const form = document.getElementById("savingsForm");
      form.addEventListener("submit", async function (e) {
        e.preventDefault();
        const amount = document.getElementById("amount").value;
        const savingsType = document.getElementById("savingsType").value;
        const duration = document.getElementById("duration").value;
        await handleCreateSavings(user, amount, savingsType, duration);
      });

      // attach back function to global so your markup still calls it
      window.goBack = goBack;

      // initial load
      await loadSavings(user);
    }

    // start
    init();
  })();
  </script>
</body>
</html>