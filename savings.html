<!-- savings.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Savings Page</title>
  <style>
  body {
    font-family: Arial, sans-serif;
    background: #f3f3f3;
    margin: 0;
    padding: 0;
  }

  .container {
    width: 90%;
    margin: auto;
    padding: 20px;
  }

  h2 {
    text-align: center;
    color: #333;
  }

  .card {
    background: #fff;
    padding: 20px;
    margin-top: 20px;
    border-radius: 10px;
    box-shadow: 0px 3px 6px rgba(0,0,0,0.1);
  }

  form label {
    display: block;
    margin: 10px 0 5px;
  }

  form input, form select {
    width: 100%;
    padding: 10px;
    margin-bottom: 15px;
  }

  button {
    background: #28a745;
    color: white;
    padding: 10px;
    border: none;
    width: 100%;
    border-radius: 5px;
    cursor: pointer;
  }

  button:hover {
    background: #218838;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
  }

  table th, table td {
    padding: 10px;
    border: 1px solid #ddd;
    text-align: center;
  }

  .action-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
  }

  .back-btn {
    background: #007bff;
    margin-top: 20px;
  }

  .back-btn:hover {
    background: #0056b3;
  }

  .disabled-btn {
    background: #ccc !important;
    cursor: not-allowed;
  }
  </style>
</head>
<body>
  <div class="container">
    <h2>ðŸ’° Savings Dashboard</h2>

    <!-- Create Savings -->
    <div class="card">
      <h3>Create Savings</h3>
      <form id="savingsForm">
        <label>Amount</label>
        <input type="number" id="amount" required>

        <label>Type</label>
        <select id="savingsType">
          <option value="flexible">Flexible</option>
          <option value="fixed">Fixed</option>
        </select>

        <label>Duration</label>
        <select id="duration">
          <option value="7">7 Days</option>
          <option value="30">30 Days</option>
          <option value="60">60 Days</option>
          <option value="180">180 Days</option>
          <option value="365">1 Year</option>
          <option value="730">2 Years</option>
          <option value="1095">3 Years</option>
        </select>

        <button type="submit">Start Saving</button>
      </form>
    </div>

    <!-- Active Savings -->
    <div class="card">
      <h3>Active Savings</h3>
      <table>
        <thead>
          <tr>
            <th>Amount</th>
            <th>Type</th>
            <th>End Date</th>
            <th>Status</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="savingsTable"></tbody>
      </table>
    </div>

    <!-- Back button -->
      <button class="back-btn" onclick="window.location.href='paymelogin.html'">â¬… Back to Dashboard</button>

  <script>
  (function(){
    // CONFIG: your backend base URL (unchanged)
    const API_BASE = "https://payme-update.onrender.com";

    // countdown intervals map
    const countdownMap = new Map();

    // read stored user from localStorage (both keys for compatibility)
    function readStoredUser() {
      const raw = localStorage.getItem("loggedInUser") || localStorage.getItem("user");
      if (!raw) return null;
      try { return JSON.parse(raw); } catch (e) { return null; }
    }

    // persist user to both keys so other pages pick updated balance/id
    function persistUser(userObj) {
      try {
        localStorage.setItem("loggedInUser", JSON.stringify(userObj));
        localStorage.setItem("user", JSON.stringify(userObj));
      } catch (e) {
        console.warn("Could not persist user to localStorage", e);
      }
    }

    // If login didn't save id, fetch /user/:phone to get id and balance
    async function ensureUserHasId(u) {
      if (!u) return null;
      if (u.id) return u;
      if (!u.phone) return u;
      try {
        const res = await fetch(`${API_BASE}/user/${encodeURIComponent(u.phone)}`);
        if (!res.ok) {
          console.warn("Could not fetch user details:", res.status);
          return u;
        }
        const data = await res.json();
        if (data && data.status === "success" && data.user) {
          const newUser = Object.assign({}, u, data.user);
          persistUser(newUser);
          return newUser;
        }
        return u;
      } catch (err) {
        console.warn("Network error while fetching user details:", err);
        return u;
      }
    }

    function toFloat(v) {
      const n = parseFloat(v);
      return isNaN(n) ? 0 : n;
    }
    function toInt(v) {
      const n = parseInt(v, 10);
      return isNaN(n) ? 0 : n;
    }

    // refresh stored balance from backend
    async function refreshStoredBalance(user) {
      if (!user || !user.phone) return;
      try {
        const res = await fetch(`${API_BASE}/balance/${encodeURIComponent(user.phone)}`);
        if (!res.ok) return;
        const d = await res.json();
        if (typeof d.balance !== "undefined") {
          user.balance = Number(d.balance);
          persistUser(user);
        }
      } catch (err) {
        // ignore network error
      }
    }

    // clear countdown intervals
    function clearCountdowns() {
      for (const id of countdownMap.keys()) {
        clearInterval(countdownMap.get(id));
      }
      countdownMap.clear();
    }

    // Start countdown for a row; when finishes reload savings to allow backend sweep
    function startCountdownForRow(id, endDate, user) {
      const timerEl = document.getElementById(`timer-${id}`);
      if (!timerEl) return;

      if (countdownMap.has(id)) {
        clearInterval(countdownMap.get(id));
        countdownMap.delete(id);
      }

      function update() {
        const now = new Date();
        const distance = new Date(endDate) - now;
        if (distance <= 0) {
          timerEl.innerText = "âœ… Completed";
          if (countdownMap.has(id)) {
            clearInterval(countdownMap.get(id));
            countdownMap.delete(id);
          }
          // small delay to let backend sweep matured savings, then reload
          setTimeout(() => loadSavings(user), 600);
          return;
        }
        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
        const hours = Math.floor((distance / (1000 * 60 * 60)) % 24);
        const mins = Math.floor((distance / (1000 * 60)) % 60);
        const secs = Math.floor((distance / 1000) % 60);
        timerEl.innerText = `${days}d ${hours}h ${mins}m ${secs}s`;
      }

      update();
      const iv = setInterval(update, 1000);
      countdownMap.set(id, iv);
    }

    // render savings table using exactly what backend returns (no aggressive filtering)
    function renderSavingsTable(rows, user) {
      const table = document.getElementById("savingsTable");
      table.innerHTML = "";

      if (!rows || rows.length === 0) {
        table.innerHTML = `<tr><td colspan="5">No savings found</td></tr>`;
        return;
      }

      rows.forEach(s => {
        const id = s.id;
        const amount = s.amount;
        // backend uses "type" but some code earlier used "savings_type" - support both
        const type = s.savings_type || s.type || "flexible";
        const endRaw = s.end_date || s.endDate || s.end || null;
        const endDate = endRaw ? new Date(endRaw) : null;
        const status = (s.status || "").toString().toLowerCase();
        // backend now returns can_withdraw boolean â€” prefer that when available
        const canWithdraw = typeof s.can_withdraw !== "undefined" ? !!s.can_withdraw : null;

        // status text
        let statusText = "Active";
        if (status === "withdrawn") statusText = "âœ… Withdrawn";
        else if (endDate && endDate <= new Date()) statusText = "Completed";

        // Decide action button:
        // - If already withdrawn -> disabled Withdrawn
        // - Else if backend says can_withdraw === true -> show Withdraw
        // - Else fallback to type/endDate checks (flexible always withdrawable, fixed only if matured)
        let actionHtml = "";
        if (status === "withdrawn") {
          actionHtml = `<button class="disabled-btn" disabled>Withdrawn</button>`;
        } else if (canWithdraw === true) {
          actionHtml = `<button data-id="${id}" class="withdraw-btn">Withdraw</button>`;
        } else if (canWithdraw === false) {
          actionHtml = `<button class="disabled-btn" disabled>Locked</button>`;
        } else {
          // fallback behavior (maintains original UX)
          if (type === "flexible") {
            actionHtml = `<button data-id="${id}" class="withdraw-btn">Withdraw</button>`;
          } else if (type === "fixed") {
            if (endDate && endDate <= new Date()) {
              actionHtml = `<button data-id="${id}" class="withdraw-btn">Withdraw</button>`;
            } else {
              actionHtml = `<button class="disabled-btn" disabled>Locked</button>`;
            }
          } else {
            actionHtml = `<button class="disabled-btn" disabled>Locked</button>`;
          }
        }

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${amount}</td>
          <td>${type}</td>
          <td>${endDate ? endDate.toLocaleString() : "-"}</td>
          <td id="timer-${id}">${statusText}</td>
          <td>
            <div class="action-container">
              ${actionHtml}
            </div>
          </td>
        `;
        table.appendChild(tr);

        // attach withdraw handler if button exists
        const btn = tr.querySelector("button.withdraw-btn");
        if (btn) {
          btn.addEventListener("click", async function () {
            const sid = toInt(this.getAttribute("data-id"));
            // disable right away to avoid double-click
            this.disabled = true;
            this.classList.add("disabled-btn");
            await handleWithdraw(user, sid, amount, type, id);
          });
        }

        // start countdown if there is an end date and not withdrawn
        if (status !== "withdrawn" && endDate) {
          startCountdownForRow(id, endDate, user);
        }
      });
    }

    // load savings call
    async function loadSavings(user) {
      if (!user || !user.id) {
        console.error("loadSavings called without user id");
        return;
      }

      clearCountdowns();
      const table = document.getElementById("savingsTable");
      table.innerHTML = `<tr><td colspan="5">Loading...</td></tr>`;

      try {
        const res = await fetch(`${API_BASE}/savings/list/${encodeURIComponent(user.id)}`);
        if (!res.ok) {
          // try to surface server error if provided
          let errText = `Failed to load savings (${res.status})`;
          try {
            const j = await res.json();
            if (j && j.message) errText = j.message;
          } catch(e){}
          table.innerHTML = `<tr><td colspan="5">${errText}</td></tr>`;
          return;
        }

        const json = await res.json();
        const rows = (json && json.savings) ? json.savings : [];
        renderSavingsTable(rows, user);
      } catch (err) {
        console.error("Error loading savings:", err);
        table.innerHTML = `<tr><td colspan="5">Error loading savings</td></tr>`;
      }
    }

    // withdraw handler
    async function handleWithdraw(user, savingsId, amount, type, rowId) {
      if (!user || !user.id) {
        alert("User not ready. Try logging in again.");
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/savings/withdraw`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user_id: user.id, savings_id: savingsId })
        });
        const json = await res.json();

        if (json && json.status === "success") {
          // immediate UI feedback
          const timerEl = document.getElementById(`timer-${savingsId}`);
          if (timerEl) timerEl.innerText = "âœ… Withdrawn";
          const btn = document.querySelector(`button[data-id="${savingsId}"]`);
          if (btn) { btn.disabled = true; btn.classList.add("disabled-btn"); btn.innerText = "Withdrawn"; }

          // refresh stored balance so dashboard sees updated balance
          await refreshStoredBalance(user);

          alert(json.message || `â‚¦${amount} withdrawn and credited to main balance.`);
          setTimeout(() => loadSavings(user), 800);
        } else {
          const msg = (json && json.message) ? json.message : "Withdrawal failed";
          alert("âŒ " + msg);
          setTimeout(() => loadSavings(user), 500);
        }
      } catch (err) {
        console.error("Withdraw error:", err);
        alert("âŒ Withdraw failed (network error)");
        setTimeout(() => loadSavings(user), 500);
      }
    }

    // create savings
    async function handleCreateSavings(user, amount, savingsType, durationDays) {
      if (!user) {
        alert("Please login first");
        return;
      }
      if (toFloat(amount) <= 0) {
        return alert("Amount must be > 0");
      }
      if (!["flexible","fixed"].includes(savingsType)) {
        return alert("Invalid savings type");
      }
      if (toInt(durationDays) <= 0) {
        return alert("Invalid duration");
      }

      try {
        const payload = {
          user_id: user.id,
          phone: user.phone,
          amount: toFloat(amount),
          savings_type: savingsType,
          duration_days: toInt(durationDays)
        };

        const res = await fetch(`${API_BASE}/savings/create`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const json = await res.json();

        if (json && json.status === "success") {
          // Update balance from backend and reload savings to show new entry
          await refreshStoredBalance(user);
          alert(json.message || "Savings created");
          setTimeout(() => loadSavings(user), 300);
        } else {
          alert("âŒ " + (json && json.message ? json.message : "Could not create savings"));
        }
      } catch (err) {
        console.error("Create savings error:", err);
        alert("âŒ Create failed (network error)");
      }
    }

    // goBack preserved (some variants of your markup call window.goBack)
    function goBack() {
      window.location.href = "paymelogin.html";
    }
    window.goBack = goBack;

    // init wiring
    async function init() {
      let stored = readStoredUser();
      if (!stored) {
        alert("Please login first");
        window.location.href = "login.html";
        return;
      }

      // ensure we have an id
      const user = await ensureUserHasId(stored);
      if (!user || !user.id) {
        alert("Could not determine your user id. Please login again.");
        window.location.href = "login.html";
        return;
      }

      // wire form submit
      const form = document.getElementById("savingsForm");
      form.addEventListener("submit", async function (e) {
        e.preventDefault();
        const amount = document.getElementById("amount").value;
        const savingsType = document.getElementById("savingsType").value;
        const duration = document.getElementById("duration").value;
        await handleCreateSavings(user, amount, savingsType, duration);
      });

      // refresh balance so stored user object is up-to-date
      await refreshStoredBalance(user);

      // initial load of savings
      await loadSavings(user);

      // clear timers when user navigates away (prevent leaking intervals)
      window.addEventListener("beforeunload", () => clearCountdowns());
    }

    // start
    init();
  })();
  </script>
</body>
</html>