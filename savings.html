<!-- savings.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Savings Page</title>
  <style>
  body {
    font-family: Arial, sans-serif;
    background: #f3f3f3;
    margin: 0;
    padding: 0;
  }

  .container {
    width: 90%;
    margin: auto;
    padding: 20px;
  }

  h2 {
    text-align: center;
    color: #333;
  }

  .card {
    background: #fff;
    padding: 20px;
    margin-top: 20px;
    border-radius: 10px;
    box-shadow: 0px 3px 6px rgba(0,0,0,0.1);
  }

  form label {
    display: block;
    margin: 10px 0 5px;
  }

  form input, form select {
    width: 100%;
    padding: 10px;
    margin-bottom: 15px;
  }

  button {
    background: #28a745;
    color: white;
    padding: 10px;
    border: none;
    width: 100%;
    border-radius: 5px;
    cursor: pointer;
  }

  button:hover {
    background: #218838;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
  }

  table th, table td {
    padding: 10px;
    border: 1px solid #ddd;
    text-align: center;
  }

  .action-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
  }

  .back-btn {
    background: #007bff;
    margin-top: 20px;
  }

  .back-btn:hover {
    background: #0056b3;
  }

  .disabled-btn {
    background: #ccc !important;
    cursor: not-allowed;
  }

  /* Modal popup styles (used to replace alerts) */
  .modal-overlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.45);
    z-index: 9999;
  }
  .modal-overlay.show {
    display: flex;
  }
  .modal {
    width: calc(100% - 48px);
    max-width: 420px;
    background: #fff;
    border-radius: 12px;
    padding: 18px;
    box-shadow: 0 18px 40px rgba(10,20,30,0.15);
    text-align: center;
  }
  .modal .badge {
    width: 68px;
    height: 68px;
    border-radius: 50%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    margin-bottom: 12px;
    color: #fff;
  }
  .modal .badge.success { background: linear-gradient(135deg,#00c853,#43a047); }
  .modal .badge.error { background: linear-gradient(135deg,#f44336,#e53935); }
  .modal h3 { margin: 6px 0 6px; font-size: 18px; }
  .modal p { margin: 0 0 12px; color: #555; }
  .modal .actions { display:flex; gap:10px; justify-content:center; margin-top:12px; }
  .modal .btn { padding: 10px 14px; border-radius:8px; cursor:pointer; border:0; font-weight:700; }
  .modal .btn-outline { background:#fff; border:1px solid #ddd; color:#333; }
  .modal .btn-primary { background:#00c853; color:#fff; border:0; }

  </style>
</head>
<body>
  <div class="container">
    <h2>ðŸ’° Savings Dashboard</h2>

    <!-- Create Savings -->
    <div class="card">
      <h3>Create Savings</h3>
      <form id="savingsForm">
        <label>Amount</label>
        <input type="number" id="amount" required>

        <label>Type</label>
        <select id="savingsType">
          <option value="flexible">Flexible</option>
          <option value="fixed">Fixed</option>
        </select>

        <label>Duration</label>
        <select id="duration">
          <option value="7">7 Days</option>
          <option value="30">30 Days</option>
          <option value="60">60 Days</option>
          <option value="180">180 Days</option>
          <option value="365">1 Year</option>
          <option value="730">2 Years</option>
          <option value="1095">3 Years</option>
        </select>

        <button type="submit">Start Saving</button>
      </form>
    </div>

    <!-- Active Savings -->
    <div class="card">
      <h3>Active Savings</h3>
      <table>
        <thead>
          <tr>
            <th>Amount</th>
            <th>Type</th>
            <th>End Date</th>
            <th>Status</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="savingsTable"></tbody>
      </table>
    </div>

    <!-- Back button -->
      <button class="back-btn" onclick="window.location.href='paymelogin.html'">â¬… Back to Dashboard</button>

  <!-- SUCCESS / ERROR POPUPS (replace alert) -->
  <div id="successModal" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="badge success">âœ“</div>
      <h3 id="successTitle">Success</h3>
      <p id="successMessage">Operation completed</p>
      <div class="actions">
        <button id="successOk" class="btn btn-primary">OK</button>
      </div>
    </div>
  </div>

  <div id="errorModal" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="alertdialog" aria-modal="true">
      <div class="badge error">âœ•</div>
      <h3 id="errorTitle">Error</h3>
      <p id="errorMessage">Something went wrong</p>
      <div class="actions">
        <button id="errorOk" class="btn btn-primary">OK</button>
      </div>
    </div>
  </div>

  <script>
  (function(){
    // CONFIG: your backend base URL (unchanged)
    const API_BASE = "https://payme-update.onrender.com";

    // modal helpers (replace alert)
    const successModal = document.getElementById('successModal');
    const successTitle = document.getElementById('successTitle');
    const successMessage = document.getElementById('successMessage');
    const successOk = document.getElementById('successOk');

    const errorModal = document.getElementById('errorModal');
    const errorTitle = document.getElementById('errorTitle');
    const errorMessage = document.getElementById('errorMessage');
    const errorOk = document.getElementById('errorOk');

    function showSuccess(message, title = "Success", onOk = null) {
      successTitle.textContent = title;
      successMessage.textContent = message || "";
      successModal.classList.add('show');
      successModal.setAttribute('aria-hidden','false');
      successOk.focus();
      // set one-time handler
      successOk.onclick = function() {
        successModal.classList.remove('show');
        successModal.setAttribute('aria-hidden','true');
        successOk.onclick = null;
        if (typeof onOk === "function") {
          try { onOk(); } catch(e){ console.warn(e); }
        }
      };
    }
    function showError(message, title = "Error", onOk = null) {
      errorTitle.textContent = title;
      errorMessage.textContent = message || "";
      errorModal.classList.add('show');
      errorModal.setAttribute('aria-hidden','false');
      errorOk.focus();
      errorOk.onclick = function() {
        errorModal.classList.remove('show');
        errorModal.setAttribute('aria-hidden','true');
        errorOk.onclick = null;
        if (typeof onOk === "function") {
          try { onOk(); } catch(e){ console.warn(e); }
        }
      };
    }

    // countdown intervals map
    const countdownMap = new Map();

    // read stored user from localStorage (both keys for compatibility)
    function readStoredUser() {
      const raw = localStorage.getItem("loggedInUser") || localStorage.getItem("user");
      if (!raw) return null;
      try { return JSON.parse(raw); } catch (e) { return null; }
    }

    // persist user to both keys so other pages pick updated balance/id
    function persistUser(userObj) {
      try {
        localStorage.setItem("loggedInUser", JSON.stringify(userObj));
        localStorage.setItem("user", JSON.stringify(userObj));
      } catch (e) {
        console.warn("Could not persist user to localStorage", e);
      }
    }

    // If login didn't save id, fetch /user/:phone to get id and balance
    async function ensureUserHasId(u) {
      if (!u) return null;
      if (u.id) return u;
      if (!u.phone) return u;
      try {
        const res = await fetch(`${API_BASE}/user/${encodeURIComponent(u.phone)}`);
        if (!res.ok) {
          console.warn("Could not fetch user details:", res.status);
          return u;
        }
        const data = await res.json();
        if (data && data.status === "success" && data.user) {
          const newUser = Object.assign({}, u, data.user);
          persistUser(newUser);
          return newUser;
        }
        return u;
      } catch (err) {
        console.warn("Network error while fetching user details:", err);
        return u;
      }
    }

    function toFloat(v) {
      const n = parseFloat(v);
      return isNaN(n) ? 0 : n;
    }
    function toInt(v) {
      const n = parseInt(v, 10);
      return isNaN(n) ? 0 : n;
    }

    // refresh stored balance from backend
    async function refreshStoredBalance(user) {
      if (!user || !user.phone) return;
      try {
        const res = await fetch(`${API_BASE}/balance/${encodeURIComponent(user.phone)}`);
        if (!res.ok) return;
        const d = await res.json();
        if (typeof d.balance !== "undefined") {
          user.balance = Number(d.balance);
          persistUser(user);
        }
      } catch (err) {
        // ignore network error
      }
    }

    // clear countdown intervals
    function clearCountdowns() {
      for (const id of countdownMap.keys()) {
        clearInterval(countdownMap.get(id));
      }
      countdownMap.clear();
    }

    // Start countdown for a row; when finishes reload savings to allow backend sweep
    function startCountdownForRow(id, endDate, user) {
      const timerEl = document.getElementById(`timer-${id}`);
      if (!timerEl) return;

      if (countdownMap.has(id)) {
        clearInterval(countdownMap.get(id));
        countdownMap.delete(id);
      }

      function update() {
        const now = new Date();
        const distance = new Date(endDate) - now;
        if (distance <= 0) {
          timerEl.innerText = "âœ… Completed";
          if (countdownMap.has(id)) {
            clearInterval(countdownMap.get(id));
            countdownMap.delete(id);
          }
          // small delay to let backend sweep matured savings, then reload
          setTimeout(() => loadSavings(user), 600);
          return;
        }
        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
        const hours = Math.floor((distance / (1000 * 60 * 60)) % 24);
        const mins = Math.floor((distance / (1000 * 60)) % 60);
        const secs = Math.floor((distance / 1000) % 60);
        timerEl.innerText = `${days}d ${hours}h ${mins}m ${secs}s`;
      }

      update();
      const iv = setInterval(update, 1000);
      countdownMap.set(id, iv);
    }

    // render savings table using exactly what backend returns (no aggressive filtering)
    function renderSavingsTable(rows, user) {
      const table = document.getElementById("savingsTable");
      table.innerHTML = "";

      if (!rows || rows.length === 0) {
        table.innerHTML = `<tr><td colspan="5">No savings found</td></tr>`;
        return;
      }

      rows.forEach(s => {
        const id = s.id;
        const amount = s.amount;
        // backend uses "type" but some code earlier used "savings_type" - support both
        const type = s.savings_type || s.type || "flexible";
        const endRaw = s.end_date || s.endDate || s.end || null;
        const endDate = endRaw ? new Date(endRaw) : null;
        const status = (s.status || "").toString().toLowerCase();
        // backend now returns can_withdraw boolean â€” prefer that when available
        const canWithdraw = typeof s.can_withdraw !== "undefined" ? !!s.can_withdraw : null;

        // status text
        let statusText = "Active";
        if (status === "withdrawn") statusText = "âœ… Withdrawn";
        else if (endDate && endDate <= new Date()) statusText = "Completed";

        // Decide action button:
        // - If already withdrawn -> disabled Withdrawn
        // - Else if backend says can_withdraw === true -> show Withdraw
        // - Else fallback to type/endDate checks (flexible always withdrawable, fixed only if matured)
        let actionHtml = "";
        if (status === "withdrawn") {
          actionHtml = `<button class="disabled-btn" disabled>Withdrawn</button>`;
        } else if (canWithdraw === true) {
          actionHtml = `<button data-id="${id}" class="withdraw-btn">Withdraw</button>`;
        } else if (canWithdraw === false) {
          actionHtml = `<button class="disabled-btn" disabled>Locked</button>`;
        } else {
          // fallback behavior (maintains original UX)
          if (type === "flexible") {
            actionHtml = `<button data-id="${id}" class="withdraw-btn">Withdraw</button>`;
          } else if (type === "fixed") {
            if (endDate && endDate <= new Date()) {
              actionHtml = `<button data-id="${id}" class="withdraw-btn">Withdraw</button>`;
            } else {
              actionHtml = `<button class="disabled-btn" disabled>Locked</button>`;
            }
          } else {
            actionHtml = `<button class="disabled-btn" disabled>Locked</button>`;
          }
        }

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${amount}</td>
          <td>${type}</td>
          <td>${endDate ? endDate.toLocaleString() : "-"}</td>
          <td id="timer-${id}">${statusText}</td>
          <td>
            <div class="action-container">
              ${actionHtml}
            </div>
          </td>
        `;
        table.appendChild(tr);

        // attach withdraw handler if button exists
        const btn = tr.querySelector("button.withdraw-btn");
        if (btn) {
          btn.addEventListener("click", async function () {
            const sid = toInt(this.getAttribute("data-id"));
            // disable right away to avoid double-click
            this.disabled = true;
            this.classList.add("disabled-btn");
            await handleWithdraw(user, sid, amount, type, id);
          });
        }

        // start countdown if there is an end date and not withdrawn
        if (status !== "withdrawn" && endDate) {
          startCountdownForRow(id, endDate, user);
        }
      });
    }

    // load savings call
    async function loadSavings(user) {
      if (!user || !user.id) {
        console.error("loadSavings called without user id");
        return;
      }

      clearCountdowns();
      const table = document.getElementById("savingsTable");
      table.innerHTML = `<tr><td colspan="5">Loading...</td></tr>`;

      try {
        const res = await fetch(`${API_BASE}/savings/list/${encodeURIComponent(user.id)}`);
        if (!res.ok) {
          // try to surface server error if provided
          let errText = `Failed to load savings (${res.status})`;
          try {
            const j = await res.json();
            if (j && j.message) errText = j.message;
          } catch(e){}
          table.innerHTML = `<tr><td colspan="5">${errText}</td></tr>`;
          return;
        }

        const json = await res.json();
        const rows = (json && json.savings) ? json.savings : [];
        renderSavingsTable(rows, user);
      } catch (err) {
        console.error("Error loading savings:", err);
        table.innerHTML = `<tr><td colspan="5">Error loading savings</td></tr>`;
      }
    }

    // withdraw handler
    async function handleWithdraw(user, savingsId, amount, type, rowId) {
      if (!user || !user.id) {
        // replaced alert with popup and return (original behavior returned immediately)
        showError("User not ready. Try logging in again.", "User not ready");
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/savings/withdraw`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user_id: user.id, savings_id: savingsId })
        });
        const json = await res.json();

        if (json && json.status === "success") {
          // immediate UI feedback
          const timerEl = document.getElementById(`timer-${savingsId}`);
          if (timerEl) timerEl.innerText = "âœ… Withdrawn";
          const btn = document.querySelector(`button[data-id="${savingsId}"]`);
          if (btn) { btn.disabled = true; btn.classList.add("disabled-btn"); btn.innerText = "Withdrawn"; }

          // refresh stored balance so dashboard sees updated balance
          await refreshStoredBalance(user);

          // replaced alert with popup; when user clicks OK, call loadSavings (to match original alert+setTimeout behavior)
          showSuccess(json.message || `â‚¦${amount} withdrawn and credited to main balance.`, "Withdrawn", function(){
            setTimeout(() => loadSavings(user), 800);
          });
        } else {
          const msg = (json && json.message) ? json.message : "Withdrawal failed";
          // replace alert + immediate setTimeout -> show popup then reload
          showError("âŒ " + msg, "Withdraw failed", function(){
            setTimeout(() => loadSavings(user), 500);
          });
        }
      } catch (err) {
        console.error("Withdraw error:", err);
        // replace alert -> show error popup then reload after dismiss
        showError("âŒ Withdraw failed (network error)", "Network error", function(){
          setTimeout(() => loadSavings(user), 500);
        });
      }
    }

    // create savings
    async function handleCreateSavings(user, amount, savingsType, durationDays) {
      if (!user) {
        // replaced alert with popup and return
        showError("Please login first", "Authentication required");
        return;
      }
      if (toFloat(amount) <= 0) {
        // replaced return alert(...) with popup + return to mimic behavior
        showError("Amount must be > 0", "Invalid amount");
        return;
      }
      if (!["flexible","fixed"].includes(savingsType)) {
        showError("Invalid savings type", "Invalid input");
        return;
      }
      if (toInt(durationDays) <= 0) {
        showError("Invalid duration", "Invalid input");
        return;
      }

      try {
        const payload = {
          user_id: user.id,
          phone: user.phone,
          amount: toFloat(amount),
          savings_type: savingsType,
          duration_days: toInt(durationDays)
        };

        const res = await fetch(`${API_BASE}/savings/create`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const json = await res.json();

        if (json && json.status === "success") {
          // Update balance from backend and reload savings to show new entry
          await refreshStoredBalance(user);
          // replaced alert with popup; after OK reload savings (to match original alert + setTimeout)
          showSuccess(json.message || "Savings created", "Saved", function(){
            setTimeout(() => loadSavings(user), 300);
          });
        } else {
          showError("âŒ " + (json && json.message ? json.message : "Could not create savings"), "Create failed");
        }
      } catch (err) {
        console.error("Create savings error:", err);
        showError("âŒ Create failed (network error)", "Network error");
      }
    }

    // goBack preserved (some variants of your markup call window.goBack)
    function goBack() {
      window.location.href = "paymelogin.html";
    }
    window.goBack = goBack;

    // init wiring
    async function init() {
      let stored = readStoredUser();
      if (!stored) {
        // replaced alert+redirect with popup -> redirect on OK to preserve flow
        showError("Please login first", "Not logged in", function(){
          window.location.href = "login.html";
        });
        return;
      }

      // ensure we have an id
      const user = await ensureUserHasId(stored);
      if (!user || !user.id) {
        showError("Could not determine your user id. Please login again.", "User error", function(){
          window.location.href = "login.html";
        });
        return;
      }

      // wire form submit
      