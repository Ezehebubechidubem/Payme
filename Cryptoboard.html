<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Payme Crypto — Dashboard</title>

  <!-- ethers v6 UMD -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.0/dist/ethers.umd.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: linear-gradient(135deg,#0f2027,#203a43,#2c5364);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin: 10px 0 20px; font-size: 26px; color: #00ffae; }
    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }
    .wallet-info { text-align: center; margin-bottom: 15px; }
    .wallet-address {
      font-family: monospace;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 10px;
      word-break: break-all;
      margin: 8px 0;
    }
    .network-toggle { display: flex; justify-content: center; gap: 12px; margin: 10px 0; }
    .network-toggle button {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      background: #1b3a4b;
      color: #fff;
    }
    .network-toggle .active { background: #00ffae; color: #00221a; }
    .balance { font-size: 24px; font-weight: bold; margin: 15px 0; color: #00ffae; }

    /* ACTIONS: always horizontal (desktop & mobile) */
    .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
      flex-direction: row; /* horizontal */
      /* allow horizontal scrolling on very narrow screens while keeping horizontal layout */
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
    }
    .actions button {
      flex: 1;           /* equal width across row */
      min-width: 80px;  /* ensures they remain usable on small screens */
      padding: 12px 16px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    .send { background: #ff6b6b; color: #fff; }
    .receive { background: #32cd32; color: #fff; }
    .buy { background: #1e90ff; color: #fff; }
    .sell { background: #ffa500; color: #fff; }

    .token-list { margin-top: 15px; }
    /* Wrapper for swipe + delete button */
    .token-row {
      position: relative;
      overflow: hidden;
      margin-bottom: 10px;
    }
    .token-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      transition: transform 0.18s ease;
      /* ensure token area sits above delete button */
      position: relative;
      z-index: 2;
    }

    /* Left column: token symbol (with optional logo) on first line, full name below */
    .token-item > div:first-child {
      display: flex;
      flex-direction: column; /* symbol on top, name below */
      align-items: flex-start;
      gap: 6px;
    }
    /* Symbol row shows logo + ticker inline */
    .symbol {
      font-weight: bold;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:15px;
    }

    /* Right column: amount on top, price below */
    .token-item > div:last-child {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    .token-amount { font-weight:800; }
    .price { color: #00ffae; font-weight: bold; }
    .pct { font-size:12px; margin-top:4px; }

    /* token image */
    .token-img { width:28px; height:28px; border-radius:50%; object-fit:cover; display:inline-block; vertical-align:middle; }

    /* PAYME testnet badge */
    .payme-badge {
      width:28px;height:28px;border-radius:50%;background:#1e90ff;color:#fff;display:inline-flex;
      align-items:center;justify-content:center;font-weight:800;font-size:12px;margin-right:8px;
    }

    /* delete button revealed on swipe */
    .delete-btn {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 84px;
      background: #ff4d4f;
      color: #fff;
      border: none;
      z-index: 1;
      transform: translateX(100%);
      transition: transform 0.18s ease;
      font-weight:700;
      border-radius:10px;
    }

    .token-row.show-delete .delete-btn { transform: translateX(0%); }
    .token-row.show-delete .token-item { transform: translateX(-84px); }

    .add-token-btn {
      display: inline-block;
      margin-top: 12px;
      padding: 10px 14px;
      background: #1e90ff;
      color: #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      border: none;
      text-align: center;
    }

    .muted { color: rgba(255,255,255,0.65); font-size:13px; }

    /* keep horizontal layout on phones — do not convert actions or token rows to vertical */
    @media (max-width:420px){
      .token-item { /* allow nowrap to keep layout */
        flex-wrap: nowrap;
      }
      .actions { gap:8px; }
      .actions button { padding:10px 12px; min-width:70px; }
    }
  </style>
</head>
<body>
  <h1>Payme Crypto</h1>

  <div class="card">
    <div class="wallet-info">
      <div>Wallet Address</div>
      <div id="walletAddr" class="wallet-address">0x1234...abcd</div>
    </div>

    <div class="network-toggle">
      <button id="mainBtn" class="active" onclick="switchNetwork('mainnet')">Mainnet</button>
      <button id="testBtn" onclick="switchNetwork('testnet')">Testnet</button>
    </div>

    <div id="balance" class="balance">$0.00 (Mainnet)</div>

    <div class="actions">
      <button class="send">Send</button>
      <button class="receive" onclick="window.location.href='receive.html'">Receive</button>
      <button class="buy">Buy</button>
      <button class="sell">Sell</button>
    </div>
  </div>

  <div id="tokens" class="card token-list">
    <button class="add-token-btn" onclick="onAddTokenClicked()">+ Add Token (CoinGecko)</button>
    <div id="addTokenStatus" style="margin-top:8px;"></div>
  </div>

  <script>
    /***********************
     * Data & storage keys
     ***********************/
    const STORAGE_WALLET = "payme_wallet";
    const STORAGE_TOKENS = "payme_tokens";
    const wallet = JSON.parse(localStorage.getItem(STORAGE_WALLET) || "{}");
    const walletAddress = wallet?.address || null;
    document.getElementById("walletAddr").innerText = walletAddress || "0x1234...abcd";

    // default mainnet tokens (CoinGecko ids)
    const DEFAULT_MAINNET_IDS = ["ethereum","binancecoin"];

    // minimal ERC20 ABI for balanceOf/decimals
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    // RPC providers (EVM networks: ETH, BSC, Polygon, Avalanche, Arbitrum, Optimism, Fantom, Aurora)
    const PROVIDERS = {
      eth: new ethers.JsonRpcProvider("https://cloudflare-eth.com"),
      bsc: new ethers.JsonRpcProvider("https://bsc-dataseed.binance.org/"),
      polygon: new ethers.JsonRpcProvider("https://rpc.ankr.com/polygon"),
      avax: new ethers.JsonRpcProvider("https://rpc.ankr.com/avalanche"),
      arbitrum: new ethers.JsonRpcProvider("https://arb1.arbitrum.io/rpc"),
      optimism: new ethers.JsonRpcProvider("https://mainnet.optimism.io"),
      fantom: new ethers.JsonRpcProvider("https://rpc.ftm.tools"),
      aurora: new ethers.JsonRpcProvider("https://mainnet.aurora.dev")
    };

    // quick mapping of coinId -> provider key for common native coins (some ids vary)
    const NATIVE_ID_TO_PROVIDER_KEY = {
      "ethereum":"eth",
      "binancecoin":"bsc",
      "polygon":"polygon",
      "polygon-pos":"polygon",
      "matic-network":"polygon",
      "avalanche-2":"avax",
      "avalanche":"avax",
      "fantom":"fantom",
      "arbitrum-one":"arbitrum",
      "arbitrum":"arbitrum",
      "optimism":"optimism",
      "aurora":"aurora"
    };

    // helper to read/write stored tokens object
    function readStoredTokens(){
      try { return JSON.parse(localStorage.getItem(STORAGE_TOKENS) || "{}"); }
      catch(e){ return {}; }
    }
    function writeStoredTokens(obj){
      localStorage.setItem(STORAGE_TOKENS, JSON.stringify(obj));
    }
    function fmt(n){ return Number(n).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:8}); }

    // token rows map: id -> elements (keeps DOM steady)
    const tokenRows = {};

    // find contract for coinId using CoinGecko detail; chooses first non-empty platform by priority
    async function findContractForCoinId(coinId){
      try {
        const res = await fetch(`https://api.coingecko.com/api/v3/coins/${encodeURIComponent(coinId)}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false&sparkline=false`);
        if(!res.ok) return null;
        const detail = await res.json();
        const platforms = detail.platforms || {};
        // look for key by heuristics: prefer EVM-like platform keys, check keys that contain substrings
        const priority = ["ethereum","binance","polygon","avalanche","arbitrum","optimism","fantom","aurora"];
        // try direct existence first
        for(const key of Object.keys(platforms)){
          if(platforms[key] && platforms[key] !== "") {
            // if key matches one of knowns, return immediately
            const lk = key.toLowerCase();
            for(const p of priority){
              if(lk.includes(p)){
                return { contract: platforms[key], platformKey: key };
              }
            }
          }
        }
        // otherwise try any platform that looks like an address
        for(const key of Object.keys(platforms)){
          if(platforms[key] && platforms[key] !== "") {
            return { contract: platforms[key], platformKey: key };
          }
        }
      } catch(e){
        console.warn("findContractForCoinId failed", coinId, e);
      }
      return null;
    }

    // update DOM row in-place for token id
    function createOrUpdateRow(id, meta){
      // meta: { symbol, name, image, price, pct, balance, priceStr (formatted) }
      let entry = tokenRows[id];
      const tokensContainer = document.getElementById("tokens");

      if(!entry){
        // create token-row wrapper with swipe & delete
        const rowWrap = document.createElement("div");
        rowWrap.className = "token-row";

        // token-item (swipe area)
        const swipe = document.createElement("div");
        swipe.className = "token-item";
        swipe.setAttribute("data-id", id);

        // inner content
        swipe.innerHTML = `
          <div>
            <div class="symbol">${meta.image ? `<img class="token-img" src="${meta.image}" alt="${meta.symbol||id}">` : (meta.isPayme ? `<span class="payme-badge">PY</span>` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`) } ${meta.symbol || id.toUpperCase()}</div>
            <div class="muted" style="font-size:13px">${meta.name || ""}</div>
          </div>
          <div>
            <div class="token-amount">${fmt(meta.balance || 0)} ${meta.symbol || ""}</div>
            <div style="display:flex; flex-direction:row; align-items:center; gap:8px; justify-content:flex-end">
              <div class="price">$${meta.priceStr}</div>
              <div class="pct" style="color: ${meta.pct >= 0 ? '#00d27a' : '#ff4d4f'}">${meta.pct>=0?'+':''}${meta.pct.toFixed(2)}%</div>
            </div>
          </div>
        `;

        // delete button (hidden until swipe)
        const delBtn = document.createElement("button");
        delBtn.className = "delete-btn";
        delBtn.innerText = "Delete";

        // append elements
        rowWrap.appendChild(swipe);
        rowWrap.appendChild(delBtn);
        tokensContainer.appendChild(rowWrap);

        // add to map
        tokenRows[id] = { wrap: rowWrap, swipe, delBtn, meta };

        // attach events: delete click
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          // remove from storage
          const stored = readStoredTokens();
          if(stored.mainnet && stored.mainnet[id]) {
            delete stored.mainnet[id];
            writeStoredTokens(stored);
          }
          // remove DOM and map
          rowWrap.parentNode && rowWrap.parentNode.removeChild(rowWrap);
          delete tokenRows[id];
          // update totals
          // (trigger re-render of totals)
        });

        // sliding / swipe logic (touch + mouse)
        addSwipeHandlers(rowWrap, swipe);

      } else {
        // update in-place values (image, balance, price, pct)
        const swipe = entry.swipe;
        // update left side (image + symbol)
        const left = swipe.children[0];
        left.querySelector('.symbol').innerHTML = `${meta.image ? `<img class="token-img" src="${meta.image}" alt="${meta.symbol||id}">` : (meta.isPayme ? `<span class="payme-badge">PY</span>` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`) } ${meta.symbol || id.toUpperCase()}`;
        left.querySelector('.muted').innerText = meta.name || "";
        // update right side
        const right = swipe.children[1];
        right.querySelector('.token-amount').innerText = `${fmt(meta.balance || 0)} ${meta.symbol || ""}`;
        right.querySelector('.price').innerText = `$${meta.priceStr}`;
        const pctEl = right.querySelector('.pct');
        pctEl.innerText = `${meta.pct>=0?'+':''}${meta.pct.toFixed(2)}%`;
        pctEl.style.color = meta.pct >= 0 ? '#00d27a' : '#ff4d4f';

        // store meta
        entry.meta = meta;
      }
    }

    // Add swipe handlers that reveal delete button on left swipe
    function addSwipeHandlers(rowWrap, swipeEl){
      let startX = 0;
      let currentX = 0;
      let touching = false;
      const deleteWidth = 84;

      function setTranslate(x){
        swipeEl.style.transform = `translateX(${x}px)`;
      }
      function onStart(clientX){
        touching = true;
        startX = clientX;
      }
      function onMove(clientX){
        if(!touching) return;
        currentX = clientX - startX;
        // only allow left swipe (negative)
        if(currentX < 0){
          const limited = Math.max(currentX, -deleteWidth);
          setTranslate(limited);
        }
      }
      function onEnd(){
        if(!touching) return;
        touching = false;
        // if moved more than half width, show delete
        if(currentX <= -deleteWidth/2){
          rowWrap.classList.add('show-delete');
        } else {
          rowWrap.classList.remove('show-delete');
          setTranslate(0);
        }
        currentX = 0;
      }

      // touch
      swipeEl.addEventListener('touchstart', e => onStart(e.touches[0].clientX), {passive:true});
      swipeEl.addEventListener('touchmove', e => onMove(e.touches[0].clientX), {passive:true});
      swipeEl.addEventListener('touchend', onEnd);

      // mouse (desktop)
      let mouseDown = false;
      swipeEl.addEventListener('mousedown', (e) => { mouseDown = true; onStart(e.clientX); e.preventDefault(); });
      window.addEventListener('mousemove', (e) => { if(mouseDown) onMove(e.clientX); });
      window.addEventListener('mouseup', (e) => { if(mouseDown){ mouseDown=false; onEnd(); } });

      // clicking the row resets delete if open
      swipeEl.addEventListener('click', () => {
        rowWrap.classList.remove('show-delete');
        setTranslate(0);
      });
    }

    // ---- CORE rendering & update flows ----

    // Build list of ids to display (mainnet/testnet)
    function getMainnetIds(stored){
      const storedMain = stored.mainnet ? Object.keys(stored.mainnet) : [];
      const idsSet = new Set([...DEFAULT_MAINNET_IDS, ...storedMain]);
      return Array.from(idsSet);
    }

    // Update prices and meta for visible tokens (in-place, no blinking).
    // This function fetches CoinGecko markets for all visible mainnet ids and updates rows.
    async function updatePricesAndDisplay(net){
      const stored = readStoredTokens();
      if(net === 'mainnet'){
        const ids = getMainnetIds(stored);
        if(ids.length === 0){
          document.getElementById("balance").innerText = `$0.00 (Mainnet)`;
          return;
        }
        // fetch market data
        let markets = [];
        try {
          const res = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=" + encodeURIComponent(ids.join(",")) + "&price_change_percentage=24h");
          markets = await res.json();
        } catch(err){
          console.warn("CoinGecko markets fetch failed", err);
          markets = [];
        }
        const marketMap = {};
        (markets || []).forEach(m => marketMap[m.id] = m);

        // compute total usd
        let totalUsd = 0;

        // iterate ids in stable order
        for(const id of ids){
          const m = marketMap[id];
          const symbol = m ? (m.symbol||id).toUpperCase() : (stored.mainnet && stored.mainnet[id] ? (stored.mainnet[id].symbol||id).toUpperCase() : id.toUpperCase());
          const name = m ? (m.name||id) : (stored.mainnet && stored.mainnet[id] ? stored.mainnet[id].name || id : id);
          const price = m ? Number(m.current_price || 0) : (stored.mainnet && stored.mainnet[id] ? Number(stored.mainnet[id].price || 0) : 0);
          const pct = m && m.price_change_percentage_24h ? Number(m.price_change_percentage_24h) : 0;
          // balance detection (on-chain) - will be updated asynchronously if wallet present
          let bal = stored.mainnet && stored.mainnet[id] && Number(stored.mainnet[id].balance) ? Number(stored.mainnet[id].balance) : 0;

          // if wallet present, attempt immediate small-scope detection for native coins
          // On-chain detection will run separately and update the row once fetched
          // For first render, show stored balance (or 0)
          const meta = {
            symbol, name, image: (m && m.image) ? m.image : null,
            priceStr: price ? fmt(price) : "0.00",
            price: price,
            pct: pct || 0,
            balance: bal,
            isPayme:false
          };
          createOrUpdateRow(id, meta);

          // accumulate usd using current balance (may be zero until on-chain fetch completes)
          const usdVal = bal * price;
          totalUsd += usdVal;
        }

        // update balance display (if very small USD show <$0.01)
        if(totalUsd > 0 && totalUsd < 0.01) {
          document.getElementById("balance").innerText = `<$0.01 (Mainnet)`;
        } else {
          document.getElementById("balance").innerText = `$${fmt(totalUsd)} (Mainnet)`;
        }

      } else {