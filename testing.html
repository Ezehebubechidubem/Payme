<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Payme Crypto — Dashboard</title>

  <!-- ethers v6 UMD (used to query RPCs & token contracts) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.0/dist/ethers.umd.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: linear-gradient(135deg,#0f2027,#203a43,#2c5364);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin: 10px 0 20px; font-size: 26px; color: #00ffae; }
    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }
    .wallet-info { text-align: center; margin-bottom: 15px; }
    .wallet-address {
      font-family: monospace;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 10px;
      word-break: break-all;
      margin: 8px 0;
    }
    .network-toggle { display: flex; justify-content: center; gap: 12px; margin: 10px 0; }
    .network-toggle button {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      background: #1b3a4b;
      color: #fff;
    }
    .network-toggle .active { background: #00ffae; color: #00221a; }
    .balance { font-size: 24px; font-weight: bold; margin: 8px 0 2px 0; color: #00ffae; }
    /* small area for $change and % */
    .balance-change { font-size: 14px; margin-bottom: 8px; }

    /* ACTIONS: always horizontal (desktop & mobile) */
    .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
      flex-direction: row; /* horizontal */
      /* allow horizontal scrolling on very narrow screens while keeping horizontal layout */
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
    }
    .actions button {
      flex: 1;           /* equal width across row */
      min-width: 80px;  /* ensures they remain usable on small screens */
      padding: 12px 16px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    .send { background: #ff6b6b; color: #fff; }
    .receive { background: #32cd32; color: #fff; }
    .buy { background: #1e90ff; color: #fff; }
    .sell { background: #ffa500; color: #fff; }

    .token-list { margin-top: 15px; }
    .token-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      margin-bottom: 10px;
    }

    /* Left column: token symbol (with optional logo) on first line, full name below */
    .token-item > div:first-child {
      display: flex;
      flex-direction: column; /* symbol on top, name below */
      align-items: flex-start;
      gap: 6px;
    }
    /* Symbol row shows logo + ticker inline */
    .symbol {
      font-weight: bold;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:15px;
    }

    /* Right column: amount on top, price below */
    .token-item > div:last-child {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    .token-amount { font-weight:800; }
    .price { color: #00ffae; font-weight: bold; }

    /* token image */
    .token-img { width:28px; height:28px; border-radius:50%; object-fit:cover; display:inline-block; vertical-align:middle; }

    /* PAYME testnet badge */
    .payme-badge {
      width:28px;height:28px;border-radius:50%;background:#1e90ff;color:#fff;display:inline-flex;
      align-items:center;justify-content:center;font-weight:800;font-size:12px;margin-right:8px;
    }

    .add-token-btn {
      display: inline-block;
      margin-top: 12px;
      padding: 10px 14px;
      background: #1e90ff;
      color: #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      border: none;
      text-align: center;
    }

    .muted { color: rgba(255,255,255,0.65); font-size:13px; }

    /* keep horizontal layout on phones — do not convert actions or token rows to vertical */
    @media (max-width:420px){
      .token-item { /* keep row layout but allow wrapping if needed */
        flex-wrap: nowrap;
      }
      .actions { gap:8px; }
      .actions button { padding:10px 12px; min-width:70px; }
    }

    /* tiny green/red helper */
    .up { color: #4cd08a; font-weight:700; }
    .down { color: #ff7b7b; font-weight:700; }
  </style>
</head>
<body>
  <h1>Payme Crypto</h1>

  <div class="card">
    <div class="wallet-info">
      <div>Wallet Address</div>
      <div id="walletAddr" class="wallet-address">0x1234...abcd</div>
    </div>

    <div class="network-toggle">
      <button id="mainBtn" class="active" onclick="switchNetwork('mainnet')">Mainnet</button>
      <button id="testBtn" onclick="switchNetwork('testnet')">Testnet</button>
    </div>

    <div id="balance" class="balance">$0.00 (Mainnet)</div>
    <div id="balanceChange" class="balance-change muted"></div>

    <div class="actions">
      <button class="send">Send</button>
      <button class="receive" onclick="window.location.href='receive.html'">Receive</button>
      <button class="buy">Buy</button>
      <button class="sell">Sell</button>
    </div>
  </div>

  <div id="tokens" class="card token-list">
    <button id="addTokenBtn" class="add-token-btn" onclick="onAddTokenClicked()">+ Add Token (CoinGecko)</button>
    <div id="addTokenStatus" style="margin-top:8px;"></div>

    <!-- token rows will be placed here (kept separate so add button isn't removed on updates) -->
    <div id="tokenRows" style="margin-top:12px;"></div>
  </div>

  <script>
    /***********************
     * Data & storage keys
     ***********************/
    const STORAGE_WALLET = "payme_wallet";
    const STORAGE_TOKENS = "payme_tokens";
    const wallet = JSON.parse(localStorage.getItem(STORAGE_WALLET) || "{}");
    const walletAddress = wallet?.address || null;
    document.getElementById("walletAddr").innerText = walletAddress || "0x1234...abcd";

    const DEFAULT_MAINNET_IDS = ["ethereum","binancecoin"];

    // minimal ERC20 ABI for balanceOf/decimals
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    // RPC providers
    const PROVIDERS = {
      eth: new ethers.JsonRpcProvider("https://cloudflare-eth.com"),
      bsc: new ethers.JsonRpcProvider("https://bsc-dataseed.binance.org/"),
      polygon: new ethers.JsonRpcProvider("https://rpc.ankr.com/polygon"),
      avax: new ethers.JsonRpcProvider("https://rpc.ankr.com/avalanche")
    };

    // Map some known CoinGecko platform keys to our providers
    const PLATFORM_TO_PROVIDER = {
      "ethereum": PROVIDERS.eth,
      "binance-smart-chain": PROVIDERS.bsc,
      "polygon-pos": PROVIDERS.polygon,
      "avalanche": PROVIDERS.avax
    };

    function readStoredTokens(){
      try { return JSON.parse(localStorage.getItem(STORAGE_TOKENS) || "{}"); }
      catch(e){ return {}; }
    }
    function writeStoredTokens(obj){
      localStorage.setItem(STORAGE_TOKENS, JSON.stringify(obj));
    }
    function fmt(n){ return Number(n).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:8}); }

    // Helpers for USD formatting with "<$0.01"
    function fmtUsd(val){
      if (val === null || val === undefined) return "$0.00";
      const v = Number(val);
      if (v !== 0 && Math.abs(v) < 0.01) return "<$0.01";
      return "$" + fmt(v);
    }
    function fmtSignedUsd(val){
      // returns like "+$0.01" or "-$0.01" or "<$0.01"
      const v = Number(val || 0);
      if (v !== 0 && Math.abs(v) < 0.01) {
        return (v >= 0 ? "+<$0.01" : "-<$0.01");
      }
      return (v >= 0 ? "+" : "-") + "$" + fmt(Math.abs(v));
    }

    // Try to obtain a contract address for a coin ID (prefer ethereum, then bsc, polygon, avax)
    async function findContractForCoinId(coinId){
      try {
        const res = await fetch(`https://api.coingecko.com/api/v3/coins/${encodeURIComponent(coinId)}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false&sparkline=false`);
        if(!res.ok) return null;
        const detail = await res.json();
        const platforms = detail.platforms || {};
        // priority order
        const order = ["ethereum","binance-smart-chain","polygon-pos","avalanche"];
        for(const pf of order){
          if(platforms[pf] && platforms[pf] !== ""){
            return { contract: platforms[pf], platform: pf };
          }
        }
      } catch (e) {
        console.warn("findContractForCoinId failed", coinId, e);
      }
      return null;
    }

    /***********************
     * Token rows management (avoid flicker)
     ***********************/
    const tokenRowsEl = document.getElementById("tokenRows");
    const tokenRowMap = new Map(); // coinId -> DOM row

    // Ensure add button stays (we use tokenRows for rows only)
    async function renderTokens(net){
      const stored = readStoredTokens();
      if(net === "mainnet"){
        const storedMain = (stored.mainnet) ? Object.keys(stored.mainnet) : [];
        const idsSet = new Set([...DEFAULT_MAINNET_IDS, ...storedMain]);
        const ids = Array.from(idsSet);

        if(ids.length === 0){
          // clear rows
          tokenRowsEl.innerHTML = "";
          tokenRowMap.clear();
          updateTopBalance(0,0);
          return;
        }

        // fetch market data from CoinGecko
        let markets = [];
        try {
          const res = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=" + encodeURIComponent(ids.join(",")) + "&price_change_percentage=24h");
          markets = await res.json();
        } catch (err) {
          console.warn("CoinGecko markets fetch failed", err);
          markets = [];
        }
        const marketMap = {};
        (markets || []).forEach(m => { marketMap[m.id] = m; });

        // compute all balances/prices and update/create rows
        let totalUsd = 0;
        let totalChangeUsd = 0;

        for (const id of ids){
          const m = marketMap[id];
          const symbol = m ? (m.symbol || id).toUpperCase() : (stored.mainnet && stored.mainnet[id] ? (stored.mainnet[id].symbol||id).toUpperCase() : id.toUpperCase());
          const name = m ? (m.name || id) : (stored.mainnet && stored.mainnet[id] ? stored.mainnet[id].name || id : id);
          const price = m ? Number(m.current_price || 0) : 0;
          const priceChange24h = m ? Number(m.price_change_24h || 0) : 0;
          const priceChangePct24h = m ? Number(m.price_change_percentage_24h || 0) : 0;

          // determine balance:
          let bal = 0;
          try {
            if(walletAddress){
              // native eth
              if(id === "ethereum"){
                const balWei = await PROVIDERS.eth.getBalance(walletAddress);
                bal = Number(ethers.formatEther(balWei));
              }
              // native bnb (BNB is native on BSC)
              else if(id === "binancecoin"){
                const balWei = await PROVIDERS.bsc.getBalance(walletAddress);
                bal = Number(ethers.formatEther(balWei));
              }
              // other token -> try to find contract and call balanceOf
              else {
                const found = await findContractForCoinId(id);
                if(found && found.contract){
                  const contractAddr = found.contract;
                  const platform = found.platform;
                  const provider = PLATFORM_TO_PROVIDER[platform] || PROVIDERS.eth;
                  const tokenContract = new ethers.Contract(contractAddr, ERC20_ABI, provider);
                  // fetch decimals & balance (graceful fallback)
                  let decimals = 18;
                  try { decimals = await tokenContract.decimals(); } catch(e){ /* keep 18 */ }
                  let raw = await tokenContract.balanceOf(walletAddress);
                  bal = Number(ethers.formatUnits(raw, decimals));
                } else {
                  // No on-chain contract found: fallback to stored balance if present
                  bal = stored.mainnet && stored.mainnet[id] ? Number(stored.mainnet[id].balance || 0) : 0;
                }
              }
            } else {
              // no wallet: fallback to stored balance
              bal = stored.mainnet && stored.mainnet[id] ? Number(stored.mainnet[id].balance || 0) : 0;
            }
          } catch(e) {
            console.warn("balance fetch failed for", id, e);
            bal = stored.mainnet && stored.mainnet[id] ? Number(stored.mainnet[id].balance || 0) : 0;
          }

          const usdVal = bal * price;
          const changeUsd = bal * priceChange24h;
          totalUsd += usdVal;
          totalChangeUsd += changeUsd;

          // create or update row
          if(tokenRowMap.has(id)){
            // update existing
            const row = tokenRowMap.get(id);
            // update amount
            const amtEl = row.querySelector(".token-amount");
            if(amtEl) amtEl.textContent = `${fmt(bal)} ${symbol}`;
            // update price
            const priceEl = row.querySelector(".price-value");
            if(priceEl) priceEl.textContent = fmtUsd(price);
            // update change
            const changeEl = row.querySelector(".price-change");
            if(changeEl){
              const pct = isFinite(priceChangePct24h) ? priceChangePct24h : 0;
              const signed = changeUsd;
              const cls = signed >= 0 ? "up" : "down";
              changeEl.innerHTML = `<span class="${cls}">${fmtSignedUsd(signed)} (${pct>=0?'+': ''}${pct.toFixed(2)}%)</span>`;
            }
            // update small image if changed
            const imgEl = row.querySelector(".token-img");
            if(imgEl && m && m.image && imgEl.src !== m.image) imgEl.src = m.image;
          } else {
            // create
            const row = document.createElement("div");
            row.className = "token-item";
            const imgHtml = (m && m.image) ? `<img class="token-img" src="${m.image}" alt="${symbol}">` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`;
            const pct = isFinite(priceChangePct24h) ? priceChangePct24h : 0;
            const changeHtml = `<span class="${(priceChange24h*bal)>=0 ? 'up' : 'down'}">${fmtSignedUsd(priceChange24h*bal)} (${pct>=0?'+': ''}${pct.toFixed(2)}%)</span>`;

            row.innerHTML = `
              <div>
                <div class="symbol">${imgHtml}${symbol}</div>
                <div class="muted" style="font-size:13px">${name}</div>
              </div>
              <div>
                <div class="token-amount">${fmt(bal)} ${symbol}</div>
                <div style="font-size:13px">${fmtUsd(price)} <span class="price-change" style="margin-left:8px">${changeHtml}</span></div>
              </div>
            `;
            tokenRowsEl.appendChild(row);
            tokenRowMap.set(id, row);
          }
        } // end for

        // update top balance and change
        updateTopBalance(totalUsd, totalChangeUsd);

      } else { // testnet
        const storedTest = stored.testnet || {};
        // we keep PYM only for testnet scenario (user requested)
        let totalUsd = 0;
        const keys = Object.keys(storedTest);
        // ensure rows correspond to test tokens only: remove any mainnet rows present
        // We'll rebuild tokenRows for testnet to keep consistent with requirement "only testnet tokens"
        tokenRowsEl.innerHTML = "";
        tokenRowMap.clear();

        if(keys.length === 0){
          // nothing to show; balance remains
        } else {
          for(const k of keys){
            const item = storedTest[k];
            const symbol = k.toUpperCase();
            const name = item.name || (k === "PYM" ? "Testnet Token" : k);
            const bal = Number(item.balance || 0);
            const price = (k === "PYM") ? 0.5 : Number(item.price || 0);
            totalUsd += bal * price;
            const row = document.createElement("div");
            row.className = "token-item";
            const imgHtml = (k === "PYM") ? `<span class="payme-badge">PY</span>` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`;
            row.innerHTML = `
              <div>
                <div class="symbol">${imgHtml}${symbol}</div>
                <div class="muted" style="font-size:13px">${name}</div>
              </div>
              <div>
                <div class="token-amount">${fmt(bal)} ${symbol}</div>
                <div style="font-size:13px">${fmtUsd(price)} <span class="price-change" style="margin-left:8px"><span class="muted">0.00 (0.00%)</span></span></div>
              </div>
            `;
            tokenRowsEl.appendChild(row);
            tokenRowMap.set(k, row);
          }
        }
        updateTopBalance(totalUsd, 0);
      }
    }

    // update top balance big number and the change line (adds +$ and +% like Trust Wallet)
    function updateTopBalance(totalUsd, totalChangeUsd){
      const balanceEl = document.getElementById("balance");
      const changeEl = document.getElementById("balanceChange");
      // format
      const display = fmtUsd(totalUsd);
      // determine percent change
      let percent = 0;
      const prev = totalUsd - totalChangeUsd;
      if(prev !== 0) percent = (totalChangeUsd / Math.abs(prev)) * 100;
      // sign class
      const cls = totalChangeUsd >= 0 ? "up" : "down";
      // show
      // preserve (Mainnet)/(Testnet) suffix — read currently active
      const activeNet = document.getElementById("mainBtn").classList.contains("active") ? "Mainnet" : "Testnet";
      balanceEl.innerText = `${display} (${activeNet})`;
      // change line — if tiny values, use < notation
      const changeUsdText = fmtSignedUsd(totalChangeUsd);
      const percentText = (Math.abs(percent) !== 0 && Math.abs(percent) < 0.01) ? "<0.01%" : `${percent >= 0 ? '+' : '-'}${Math.abs(percent).toFixed(2)}%`;
      changeEl.innerHTML = `<span class="${cls}">${changeUsdText}</span> <span class="muted" style="margin-left:8px">${percentText}</span>`;
    }

    // initial render default mainnet
    renderTokens("mainnet");

    // Keep prices live for mainnet tokens (refresh every 15s) — update in-place to avoid blink
    setInterval(async () => {
      const mainActive = document.getElementById("mainBtn").classList.contains("active");
      if(mainActive){
        await renderTokens("mainnet");
      } else {
        await renderTokens("testnet");
      }
    }, 15000);

    /***********************
     * Network switching
     ***********************/
    function switchNetwork(net){
      document.getElementById("mainBtn").classList.remove("active");
      document.getElementById("testBtn").classList.remove("active");
      if(net==="mainnet"){document.getElementById("mainBtn").classList.add("active");}
      else{document.getElementById("testBtn").classList.add("active");}
      renderTokens(net);
    }

    /***********************
     * Add token flow (CoinGecko) — NO BALANCE PROMPT
     * - search endpoint -> user chooses coin -> store coin.id + metadata
     * - balance will be detected automatically from the connected wallet (if available)
     ***********************/
  