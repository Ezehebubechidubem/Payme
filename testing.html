<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Payme Crypto — Dashboard</title>

  <!-- ethers v6 UMD -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.0/dist/ethers.umd.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: linear-gradient(135deg,#0f2027,#203a43,#2c5364);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin: 10px 0 20px; font-size: 26px; color: #00ffae; }
    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }
    .wallet-info { text-align: center; margin-bottom: 15px; }
    .wallet-address {
      font-family: monospace;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 10px;
      word-break: break-all;
      margin: 8px 0;
    }
    .network-toggle { display: flex; justify-content: center; gap: 12px; margin: 10px 0; }
    .network-toggle button {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      background: #1b3a4b;
      color: #fff;
    }
    .network-toggle .active { background: #00ffae; color: #00221a; }
    .balance { font-size: 24px; font-weight: bold; margin: 15px 0; color: #00ffae; }

    /* ACTIONS: always horizontal (desktop & mobile) */
    .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
      flex-direction: row; /* horizontal */
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
    }
    .actions button {
      flex: 1;
      min-width: 80px;
      padding: 12px 16px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    .send { background: #ff6b6b; color: #fff; }
    .receive { background: #32cd32; color: #fff; }
    .buy { background: #1e90ff; color: #fff; }
    .sell { background: #ffa500; color: #fff; }

    .token-list { margin-top: 15px; }

    /* swipe-row wrapper holds token item and delete button */
    .swipe-row {
      position: relative;
      margin-bottom: 10px;
      touch-action: pan-y;
      overflow: visible;
    }

    .swipe-content {
      transition: transform 160ms ease;
      will-change: transform;
      position: relative;
      z-index: 2;
    }

    .delete-btn {
      position: absolute;
      right: 12px;
      top: 12px;
      bottom: 12px;
      width: 84px;
      border-radius: 8px;
      border: none;
      background: #ff4d4f;
      color: #fff;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      cursor: pointer;
      visibility: hidden;   /* hidden until slide */
      opacity: 0;
      transform: translateX(0);
      transition: opacity 120ms ease, visibility 120ms;
    }

    .delete-btn.visible {
      visibility: visible;
      opacity: 1;
    }

    .token-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
    }

    /* Left column: token symbol (with optional logo) on first line, full name below */
    .token-item > div:first-child {
      display: flex;
      flex-direction: column; /* symbol on top, name below */
      align-items: flex-start;
      gap: 6px;
    }
    /* Symbol row shows logo + ticker inline */
    .symbol {
      font-weight: bold;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:15px;
    }

    /* Right column: amount on top, price below */
    .token-item > div:last-child {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    .token-amount { font-weight:800; }
    .price { color: #00ffae; font-weight: bold; }

    .price-pct { font-size:12px; margin-left:8px; font-weight:700; }

    /* token image */
    .token-img { width:28px; height:28px; border-radius:50%; object-fit:cover; display:inline-block; vertical-align:middle; }

    /* PAYME testnet badge */
    .payme-badge {
      width:28px;height:28px;border-radius:50%;background:#1e90ff;color:#fff;display:inline-flex;
      align-items:center;justify-content:center;font-weight:800;font-size:12px;margin-right:8px;
    }

    .add-token-btn {
      display: inline-block;
      margin-top: 12px;
      padding: 10px 14px;
      background: #1e90ff;
      color: #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      border: none;
      text-align: center;
    }

    .muted { color: rgba(255,255,255,0.65); font-size:13px; }

    /* keep horizontal layout on phones — do not convert actions or token rows to vertical */
    @media (max-width:420px){
      .token-item { flex-wrap: nowrap; }
      .actions { gap:8px; }
      .actions button { padding:10px 12px; min-width:70px; }
    }
  </style>
</head>
<body>
  <h1>Payme Crypto</h1>

  <div class="card">
    <div class="wallet-info">
      <div>Wallet Address</div>
      <div id="walletAddr" class="wallet-address">0x1234...abcd</div>
    </div>

    <div class="network-toggle">
      <button id="mainBtn" class="active" onclick="switchNetwork('mainnet')">Mainnet</button>
      <button id="testBtn" onclick="switchNetwork('testnet')">Testnet</button>
    </div>

    <div id="balance" class="balance">$0.00 (Mainnet)</div>

    <div class="actions">
      <button class="send">Send</button>
      <button class="receive" onclick="window.location.href='receive.html'">Receive</button>
      <button class="buy">Buy</button>
      <button class="sell">Sell</button>
    </div>
  </div>

  <div id="tokens" class="card token-list">
    <!-- static add button and status (do not remove or replace) -->
    <button id="addTokenBtn" class="add-token-btn" onclick="onAddTokenClicked()">+ Add Token (CoinGecko)</button>
    <div id="addTokenStatus" style="margin-top:8px;"></div>

    <!-- token rows will be placed here -->
    <div id="tokenRows" style="margin-top:12px;"></div>
  </div>

  <script>
    /***********************
     * Data & storage keys
     ***********************/
    const STORAGE_WALLET = "payme_wallet";
    const STORAGE_TOKENS = "payme_tokens";
    const wallet = JSON.parse(localStorage.getItem(STORAGE_WALLET) || "{}");
    const walletAddress = wallet?.address || null;
    document.getElementById("walletAddr").innerText = walletAddress || "0x1234...abcd";

    const DEFAULT_MAINNET_IDS = ["ethereum","binancecoin"];

    // minimal ERC20 ABI
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    // simple provider map for common chains
    const PROVIDERS = {
      ethereum: new ethers.JsonRpcProvider("https://cloudflare-eth.com"),
      "binance-smart-chain": new ethers.JsonRpcProvider("https://bsc-dataseed.binance.org/"),
      "polygon-pos": new ethers.JsonRpcProvider("https://rpc.ankr.com/polygon"),
      avalanche: new ethers.JsonRpcProvider("https://rpc.ankr.com/avalanche")
    };

    // map coinGecko platform key to our provider
    const PLATFORM_TO_PROVIDER = {
      "ethereum": PROVIDERS.ethereum,
      "binance-smart-chain": PROVIDERS["binance-smart-chain"],
      "polygon-pos": PROVIDERS["polygon-pos"],
      "avalanche": PROVIDERS.avalanche
    };

    function readStoredTokens(){
      try { return JSON.parse(localStorage.getItem(STORAGE_TOKENS) || "{}"); }
      catch(e){ return {}; }
    }
    function writeStoredTokens(obj){
      localStorage.setItem(STORAGE_TOKENS, JSON.stringify(obj));
    }
    function fmt(n){ return Number(n).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:8}); }

    let CURRENT_NET = "mainnet";

    /***********************
     * Find token contract via CoinGecko detail
     ***********************/
    async function findContractForCoinId(coinId){
      try {
        const res = await fetch(`https://api.coingecko.com/api/v3/coins/${encodeURIComponent(coinId)}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false&sparkline=false`);
        if(!res.ok) return null;
        const detail = await res.json();
        const platforms = detail.platforms || {};
        const order = ["ethereum","binance-smart-chain","polygon-pos","avalanche"];
        for(const pf of order){
          if(platforms[pf] && platforms[pf] !== "") {
            return { contract: platforms[pf], platform: pf };
          }
        }
      } catch(e){
        console.warn("findContractForCoinId failed", coinId, e);
      }
      return null;
    }

    /***********************
     * Swipe handlers (mouse & touch)
     ***********************/
    let openRow = null;

    function attachSwipeHandlers(wrapper, contentEl, deleteBtn) {
      // initial deleteBtn hidden
      deleteBtn.classList.remove("visible");

      const maxTranslate = deleteBtn.offsetWidth + 12;
      let pointerId = null, startX = 0, translateX = 0, dragging = false;

      function setTranslate(x){
        translateX = x;
        contentEl.style.transform = `translateX(${x}px)`;
        // show delete when moved a bit left
        if (x < -10) deleteBtn.classList.add("visible");
        else deleteBtn.classList.remove("visible");
      }

      function open(){
        setTranslate(-maxTranslate);
        deleteBtn.classList.add("visible");
        openRow = wrapper;
      }
      function close(){
        setTranslate(0);
        deleteBtn.classList.remove("visible");
        if(openRow === wrapper) openRow = null;
      }

      wrapper.addEventListener("pointerdown", (e)=>{
        if (e.button && e.button !== 0) return;
        // if another row is open, close it
        if (openRow && openRow !== wrapper){
          const other = openRow;
          const otherContent = other.querySelector(".swipe-content");
          const otherDel = other.querySelector(".delete-btn");
          if (otherContent) otherContent.style.transform = "translateX(0px)";
          if (otherDel) otherDel.classList.remove("visible");
          openRow = null;
        }
        pointerId = e.pointerId;
        wrapper.setPointerCapture(pointerId);
        startX = e.clientX;
        dragging = true;
      });

      wrapper.addEventListener("pointermove", (e)=>{
        if(!dragging || e.pointerId !== pointerId) return;
        const dx = e.clientX - startX;
        if (dx < 0) {
          const x = Math.max(dx, -maxTranslate);
          setTranslate(x);
        } else {
          // slight right drag bounce
          setTranslate(Math.min(dx * 0.2, 0));
        }
      });

      function finish(e){
        if(!dragging) return;
        dragging = false;
        // if sufficiently left, open, else close
        if (translateX <= -maxTranslate/2) open();
        else close();
        try { wrapper.releasePointerCapture(pointerId); } catch(e){}
        pointerId = null;
      }

      wrapper.addEventListener("pointerup", finish);
      wrapper.addEventListener("pointercancel", finish);
      wrapper.addEventListener("pointerleave", (e)=>{
        if(dragging && e.pointerId === pointerId) finish(e);
      });

      // clicking content while open should close it
      contentEl.addEventListener("click", (ev)=>{
        if(openRow === wrapper && Math.abs(translateX) > 6){
          ev.preventDefault();
          ev.stopPropagation();
          close();
        }
      });

      // delete handler (confirmation + remove)
      deleteBtn.addEventListener("click", (ev)=>{
        ev.stopPropagation();
        const id = wrapper.dataset.id;
        const net = wrapper.dataset.net;
        if(!confirm(`Delete ${id} from ${net}?`)) {
          // close row after cancel
          contentEl.style.transform = "translateX(0px)";
          deleteBtn.classList.remove("visible");
          return;
        }
        const stored = readStoredTokens();
        if (net === "mainnet" && stored.mainnet && stored.mainnet[id]) delete stored.mainnet[id];
        if (net === "testnet" && stored.testnet && stored.testnet[id]) delete stored.testnet[id];
        writeStoredTokens(stored);
        // remove wrapper from DOM smoothly
        wrapper.style.transition = "height 200ms ease, margin 200ms ease, opacity 180ms";
        wrapper.style.height = wrapper.offsetHeight + "px";
        requestAnimationFrame(()=>{
          wrapper.style.height = "0px";
          wrapper.style.marginBottom = "0px";
          wrapper.style.opacity = "0";
        });
        setTimeout(()=> renderTokens(CURRENT_NET), 240);
      });
    }

    /***********************
     * Render tokens initially (build DOM once)
     * After initial build we update inline (prices & balances) via updater loops
     ***********************/
    async function renderTokens(net){
      CURRENT_NET = net;
      const tokenRows = document.getElementById("tokenRows");
      const addStatus = document.getElementById("addTokenStatus");
      addStatus.innerText = "";

      const stored = readStoredTokens();
      const hasWallet = !!walletAddress;

      // collect list of tokens to display
      let rowsToShow = [];

      if (net === "mainnet") {
        const storedMain = stored.mainnet ? Object.keys(stored.mainnet) : [];
        const idsSet = new Set([...DEFAULT_MAINNET_IDS, ...storedMain]);
        const ids = Array.from(idsSet);
        // build initial placeholders from ids
        ids.forEach(id => {
          rowsToShow.push({ type: "coingecko", id });
        });
      } else { // testnet
        const keys = stored.testnet ? Object.keys(stored.testnet) : [];
        keys.forEach(k => {
          rowsToShow.push({ type: "testnet", id: k });
        });
      }

      // Build fragment and append all rows (do not clear add button or status)
      const frag = document.createDocumentFragment();

      if (rowsToShow.length === 0) {
        // clear existing token rows (but keep add/status)
        tokenRows.replaceChildren();
        document.getElementById("balance").innerText = net === "mainnet" ? "$0.00 (Mainnet)" : "$0.00 (Testnet)";
        return;
      }

      // We'll fetch market info for all CoinGecko ids in one call for mainnet
      let marketMap = {};
      if (net === "mainnet"){
        const ids = rowsToShow.map(r => r.id).join(",");
        try {
          const mres = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids="+encodeURIComponent(ids)+"&price_change_percentage=24h");
          const markets = await mres.json();
          (markets || []).forEach(m => { marketMap[m.id] = m; });
        } catch(e){
          console.warn("market fetch failed", e);
        }
      }

      // For each row create wrapper + content + delete button (delete hidden initially)
      for (const r of rowsToShow){
        if (r.type === "coingecko") {
          const id = r.id;
          const m = marketMap[id] || null;
          const symbol = m ? (m.symbol||id).toUpperCase() : (stored.mainnet && stored.mainnet[id] ? (stored.mainnet[id].symbol||id).toUpperCase() : id.toUpperCase());
          const name = m ? (m.name||id) : (stored.mainnet && stored.mainnet[id] ? stored.mainnet[id].name||id : id);
          const price = m ? Number(m.current_price || 0) : 0;
          const pct24 = m ? Number(m.price_change_percentage_24h || 0) : 0;
          const balFallback = stored.mainnet && stored.mainnet[id] ? Number(stored.mainnet[id].balance || 0) : 0;

          // create node structure
          const wrapper = document.createElement("div");
          wrapper.className = "swipe-row";
          wrapper.dataset.id = id;
          wrapper.dataset.net = "mainnet";

          const contentWrap = document.createElement("div");
          contentWrap.className = "swipe-content";

          const tokenItem = document.createElement("div");
          tokenItem.className = "token-item";

          // left HTML
          const imgHtml = (m && m.image) ? `<img class="token-img" src="${m.image}" alt="${symbol}">` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`;
          // right HTML placeholders (we will update values live)
          tokenItem.innerHTML = `
            <div>
              <div class="symbol">${imgHtml}${symbol}</div>
              <div class="muted" style="font-size:13px">${name}</div>
            </div>
            <div>
              <div class="token-amount" data-id="${id}">${fmt(balFallback)} ${symbol}</div>
              <div style="display:flex;align-items:center;justify-content:flex-end">
                <div class="price" data-price-id="${id}">$${fmt(price)}</div>
                <div class="price-pct" data-pct-id="${id}" style="margin-left:8px;color:${pct24>=0? '#7fffb6':'#ff9b9b'}">${pct24>=0? '▲':'▼'} ${Math.abs(Number(pct24||0)).toFixed(2)}%</div>
              </div>
            </div>
          `;

          contentWrap.appendChild(tokenItem);

          const delBtn = document.createElement("button");
          delBtn.className = "delete-btn";
          delBtn.type = "button";
          delBtn.textContent = "Delete";

          wrapper.appendChild(contentWrap);
          wrapper.appendChild(delBtn);

          frag.appendChild(wrapper);

          // attach swipe handlers (after appended to DOM we set them, but attach now - deleteBtn.offsetWidth may be 0 until inserted; we'll attach after replacing children)
        } else if (r.type === "testnet") {
          const k = r.id;
          const storedTest = readStoredTokens().testnet || {};
          const item = storedTest[k] || {};
          const symbol = k.toUpperCase();
          const name = item.name || (k === "PYM" ? "Testnet Token" : k);
          const bal = Number(item.balance || 0);
          const price = k === "PYM" ? 0.5 : (item.price || 0);

          const wrapper = document.createElement("div");
          wrapper.className = "swipe-row";
          wrapper.dataset.id = k;
          wrapper.dataset.net = "testnet";

          const contentWrap = document.createElement("div");
          contentWrap.className = "swipe-content";

          const tokenItem = document.createElement("div");
          tokenItem.className = "token-item";

          const imgHtml = (k === "PYM") ? `<span class="payme-badge">PY</span>` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`;

          tokenItem.innerHTML = `
            <div>
              <div class="symbol">${imgHtml}${symbol}</div>
              <div class="muted" style="font-size:13px">${name}</div>
            </div>
            <div>
              <div class="token-amount" data-id="${k}">${fmt(bal)} ${symbol}</div>
              <div class="price" data-price-id="${k}">$${fmt(price)}</div>
            </div>
          `;

          contentWrap.appendChild(tokenItem);
          const delBtn = document.createElement("button");
          delBtn.className = "delete-btn";
          delBtn.type = "button";
          delBtn.textContent = "Delete";

          wrapper.appendChild(contentWrap);
          wrapper.appendChild(delBtn);
          frag.appendChild(wrapper);
        }
      } // end for rows

      // replace tokenRows children in one go (prevents flicker)
      tokenRows.replaceChildren(frag);

      // Now that DOM nodes exist, attach swipe handlers for each wrapper
      Array.from(tokenRows.quer