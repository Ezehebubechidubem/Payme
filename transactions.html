<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recent Transactions</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet"/>
  <style>
    :root{
      --primary:#00c853;
      --success:#2e7d32;
      --pending:#f0ad4e;
      --failed:#d32f2f;
      --muted:#777;
      --bg:#ffffff;
      --card:#ffffff;
      --line:#e9ecef;
      --text:#111;
      --avatar-bg:#e8f5e9;
      --avatar-color:#2e7d32;
      --radius:12px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      min-height:100vh;
      display:flex;flex-direction:column;
    }
    header{
      display:flex;align-items:center;padding:12px 14px;border-bottom:1px solid var(--line);background:#fff;
      position:sticky;top:0;z-index:10;
    }
    header a.back{color:var(--text);text-decoration:none;margin-right:10px;font-size:18px}
    header h2{flex:1;text-align:center;font-size:16px;margin:0;font-weight:700}
    main{flex:1;overflow:auto;padding:12px}
    .month-group{margin-bottom:18px}
    .month-title{font-size:18px;font-weight:700;margin:6px 4px 12px;color:#222}
    .tx-card{
      background:var(--card);border-radius:12px;padding:12px 14px;margin-bottom:12px;border:1px solid var(--line);
      display:flex;align-items:center;gap:12px;
    }
    .avatar{
      width:52px;height:52px;border-radius:10px;background:var(--avatar-bg);display:grid;place-items:center;
      font-weight:700;color:var(--avatar-color);font-size:18px;flex:0 0 52px;
    }
    .tx-main{flex:1;min-width:0}
    .tx-top{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .other-name{font-size:15px;font-weight:700;color:#111;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .meta{font-size:13px;color:var(--muted);margin-top:6px}
    .meta small{display:block;color:var(--muted);font-size:12px;margin-top:6px}
    .tx-amount{font-weight:800;font-size:16px;white-space:nowrap}
    .status{
      font-weight:700;font-size:13px;padding:6px 10px;border-radius:999px;text-transform:lowercase;
      display:inline-block;margin-left:10px;
    }
    .status.success{color:var(--success)}
    .status.pending{color:var(--pending)}
    .status.failed{color:var(--failed)}
    /* new: direction badge (placed under status as requested) */
    .direction-badge{
      display:block;
      font-weight:700;
      font-size:12px;
      margin-top:6px;
      text-transform:capitalize;
      color:var(--muted);
    }
    .empty{padding:36px;text-align:center;color:var(--muted)}
    /* small screens tweak */
    @media (max-width:420px){
      .avatar{width:48px;height:48px;font-size:16px}
      .tx-amount{font-size:15px}
    }
  </style>
</head>
<body>
  <header>
    <a class="back" href="javascript:void(0)" onclick="goBack()"><i class="fa-solid fa-arrow-left"></i></a>
    <h2>Recent Transactions</h2>
    <div style="width:26px"></div>
  </header>

  <main id="main">
    <div id="loading" class="empty">Loading transactions…</div>
    <div id="content"></div>
  </main>

<script>
  // === CONFIG ===
  const API_BASE = "https://payme-update.onrender.com"; // keep as your backend base
  // === END CONFIG ===

  // get logged user (from your app's storage keys)
  function getStoredUser(){
    try{
      const j = localStorage.getItem("loggedInUser") || localStorage.getItem("user");
      return j ? JSON.parse(j) : null;
    }catch(e){ return null; }
  }

  function goBack(){
    if(document.referrer && document.referrer!=='') window.history.back();
    else window.location.href = "paymelogin.html";
  }

  // parse and format date to "DD/MM/YYYY , HH:MM:SS"
  function formatDateTime(iso){
    if(!iso) return '';
    const d = new Date(iso);
    if(isNaN(d.getTime())) return iso;
    const pad = v => String(v).padStart(2,'0');
    const dd = pad(d.getDate()), mm = pad(d.getMonth()+1), yy = d.getFullYear();
    const hh = pad(d.getHours()), min = pad(d.getMinutes()), ss = pad(d.getSeconds());
    return `${dd}/${mm}/${yy} , ${hh}:${min}:${ss}`;
  }

  // group transactions array by month-year key
  function groupByMonth(transactions){
    const map = new Map();
    for(const tx of transactions){
      let dt = new Date(tx.date);
      if(isNaN(dt.getTime())) dt = new Date(); // fallback
      const key = dt.toLocaleString('en-US', { month: 'long', year: 'numeric' }); // e.g. "December 2025"
      if(!map.has(key)) map.set(key, []);
      map.get(key).push(tx);
    }
    // maintain order by latest month first
    return Array.from(map.entries()).sort((a,b)=>{
      const pa = new Date(a[0]); const pb = new Date(b[0]);
      return pb - pa;
    });
  }

  // determine status (best-effort): prefer tx.status, else look for keywords in type
  function determineStatus(tx){
    if(tx.status) {
      return String(tx.status).toLowerCase();
    }
    const t = (tx.type||'').toLowerCase();
    if(t.includes('fail') || t.includes('failed') || t.includes('error')) return 'failed';
    if(t.includes('pend') || t.includes('pending')) return 'pending';
    // default
    return 'success';
  }

  // determine direction (IN / OUT) best-effort
  function determineDirection(tx, parsed){
    // priority: explicit fields from API
    try{
      if(tx.raw){
        const r = tx.raw;
        if(r.direction && typeof r.direction === 'string'){
          const d = r.direction.toLowerCase();
          if(d === 'in' || d === 'out') return d;
          if(d.includes('credit')) return 'in';
          if(d.includes('debit')) return 'out';
        }
        if(r.side && typeof r.side === 'string'){
          const s = r.side.toLowerCase();
          if(s === 'in' || s === 'out') return s;
          if(s.includes('credit')) return 'in';
          if(s.includes('debit')) return 'out';
        }
        // some APIs might provide boolean flags
        if(r.credit === true) return 'in';
        if(r.debit === true) return 'out';
        // some raw types contain words
        if(r.type && typeof r.type === 'string'){
          const t = r.type.toLowerCase();
          if(t.includes('credit') || t.includes('received') || t.includes('topup') || t.includes('deposit')) return 'in';
          if(t.includes('debit') || t.includes('sent') || t.includes('send') || t.includes('withdraw') || t.includes('airtime') || t.includes('payment')) return 'out';
        }
      }
    }catch(e){
      // ignore
    }

    // fallback based on parsed.kind or tx.type string
    const kind = (parsed && parsed.kind) ? parsed.kind.toLowerCase() : (String(tx.type || '').toLowerCase());
    if(kind){
      if(kind.includes('airtime') || kind.includes('send') || kind.includes('transfer') || kind.includes('pay') || kind.includes('withdraw')) return 'out';
      if(kind.includes('receive') || kind.includes('credit') || kind.includes('deposit') || kind.includes('topup')) return 'in';
    }

    // If amount is present and there is a fee field, likely an outgoing payment
    const amt = Number(tx.amount || 0);
    const fee = (parsed && parsed.fee != null) ? Number(parsed.fee) : (tx.raw && tx.raw.fee != null ? Number(tx.raw.fee) : null);
    if(amt > 0 && fee != null) return 'out';

    // last resort: treat as 'out' for transfer-like and 'in' otherwise — default 'out' to be conservative
    return 'out';
  }

  // friendly currency format (no locale surprises)
  function formatCurrency(n){
    const num = Number(n) || 0;
    // show thousands separators
    return '₦' + num.toLocaleString('en-NG');
  }

  // Caching for lookups to avoid repeated network calls
  const nameCache = new Map(); // key -> {name, avatarUrl?}
  async function lookupNameForOther(other){
    if(!other) return { name: other || '', avatar: null };

    // If cached
    if(nameCache.has(other)) return nameCache.get(other);

    // heuristics: account numbers are 10-digit and start 7/8/9 (per your instruction)
    const digitsOnly = String(other).replace(/\D/g,'');
    try {
      // account number (10 digits starting with 7/8/9)
      if(/^[789]\d{9}$/.test(digitsOnly)){
        const acc = digitsOnly.slice(0,10);
        const url = `${API_BASE}/user_by_account/${encodeURIComponent(acc)}`;
        const res = await fetch(url, { cache:'no-store' });
        if(res.ok){
          const json = await res.json().catch(()=>null);
          if(json && json.status === 'success' && json.username){
            const out = { name: json.username, avatar: null, phone: json.phone || null };
            nameCache.set(other, out);
            return out;
          }
        }
      }

      // else maybe it's a phone (11 digits)
      if(/^\d{11}$/.test(digitsOnly)){
        const phone = digitsOnly;
        const url = `${API_BASE}/user/${encodeURIComponent(phone)}`;
        const res = await fetch(url, { cache:'no-store' });
        if(res.ok){
          const json = await res.json().catch(()=>null);
          // endpoints may return {status:"success", user: {...}}
          if(json && json.status === 'success' && json.user){
            const u = json.user;
            const out = { name: u.username || u.name || phone, avatar: u.avatar || u.picture || null, phone: u.phone || phone };
            nameCache.set(other, out);
            return out;
          }
          // or raw object
          if(json && (json.username || json.name)){
            const out = { name: json.username || json.name, avatar: json.avatar || json.picture || null, phone: json.phone || phone };
            nameCache.set(other, out);
            return out;
          }
        }
      }
    } catch(e){
      // ignore network issues, fallthrough to fallback name
    }

    // fallback: return original string as name
    const fallback = { name: String(other), avatar: null };
    nameCache.set(other, fallback);
    return fallback;
  }

  // Build a visual avatar content (initials or digit)
  function avatarContent(nameOrOther){
    if(!nameOrOther) return '';
    const s = String(nameOrOther).trim();
    // if starts with digit show that digit (like screenshot)
    const m = s.match(/[A-Za-z]/);
    if(!m){
      // show first digit char
      const d = s.match(/\d/);
      return d ? d[0] : s.slice(0,1).toUpperCase();
    }
    // create initials (two letters)
    const parts = s.split(/\s+/).filter(Boolean);
    if(parts.length === 1) return parts[0].slice(0,1).toUpperCase();
    return (parts[0].slice(0,1) + parts[1].slice(0,1)).toUpperCase();
  }

  // --- New helper: parse type/details from string patterns like:
  // "airtime|network:MTN|to:07042032134|fee:10|value:1000.0"
  function parseTypeDetails(tx){
    const out = { kind: '', network: null, to: null, fee: null, value: null, rawSegments: [] };
    const t = String(tx.type || tx.raw?.type || tx.raw || '').trim();
    if(!t) return out;
    // normalize separators (both '|' and ' ' and ';' may be possible)
    const segs = t.split('|').map(s=>s.trim()).filter(Boolean);
    // if not pipe-separated, try splitting by spaces but keep the whole string as fallback
    if(segs.length === 1 && segs[0].indexOf(':') === -1){
      // might be a simple type string like "airtime" or "balance_send"
      out.kind = segs[0].toLowerCase();
      out.rawSegments = segs;
      return out;
    }
    out.rawSegments = segs;
    // first segment often contains kind
    out.kind = segs[0].toLowerCase();
    for(let i=1;i<segs.length;i++){
      const s = segs[i];
      const [k, ...rest] = s.split(':');
      const val = rest.join(':'); // in case ":" appears in value
      if(!k) continue;
      const key = k.trim().toLowerCase();
      const v = val ? val.trim() : '';
      if(key === 'network') out.network = v;
      else if(key === 'to' || key === 'recipient' || key === 'phone') out.to = v;
      else if(key === 'fee') out.fee = isFinite(Number(v)) ? Number(v) : null;
      else if(key === 'value' || key === 'amount') out.value = isFinite(Number(v)) ? Number(v) : null;
      else {
        // sometimes segments may be like "airtime" again or "MTN" — treat as fallback
      }
    }
    return out;
  }

  // Compute the amount to show to user (exclude fee for balance send & similar)
  function computeDisplayedAmount(tx, parsed){
    // priority: parsed.value if present
    if(parsed && parsed.value != null) return parsed.value;
    // if raw object contains value/amount fields, prefer those (many APIs return "value" separate from "amount-with-fee")
    if(tx.raw && (tx.raw.value != null || tx.raw.amount != null)){
      // prefer raw.value
      if(tx.raw.value != null) return Number(tx.raw.value);
      return Number(tx.raw.amount);
    }
    // else if tx.amount exists and tx.raw.fee exists, attempt to subtract fee for "send"/"balance" operations
    const amt = Number(tx.amount) || 0;
    const feeFromRaw = tx.raw && (tx.raw.fee != null) ? Number(tx.raw.fee) : null;
    // If parsed fee exists, use it
    const parsedFee = parsed && parsed.fee != null ? Number(parsed.fee) : null;

    // decide when to subtract fee: if tx type suggests send/transfer or parsed.kind includes 'send'/'transfer'/'balance'
    const kind = (parsed && parsed.kind) ? parsed.kind.toLowerCase() : (String(tx.type || '').toLowerCase());
    const isSendLike = kind.includes('send') || kind.includes('transfer') || kind.includes('balance') || kind.includes('p2p') || kind.includes('send-money');

    if(isSendLike){
      // prefer parsed fee, then raw fee
      const feeToUse = parsedFee != null ? parsedFee : (feeFromRaw != null ? feeFromRaw : 0);
      // Some APIs already give 'amount' as the value to user (no fee included) — but if amount includes fee and fee present, subtract.
      return Math.max(0, amt - Number(feeToUse || 0));
    }

    // default: return tx.amount (as given)
    return amt;
  }

  // Render grouped transactions
  async function renderTransactions(){
    const main = document.getElementById('main');
    const loading = document.getElementById('loading');
    const content = document.getElementById('content');

    const user = getStoredUser();
    if(!user || !user.phone){
      loading.innerText = 'Please login first (no logged user found).';
      return;
    }

    loading.innerText = 'Loading transactions…';
    content.innerHTML = '';

    try {
      const res = await fetch(`${API_BASE}/transactions/${encodeURIComponent(user.phone)}`, { cache:'no-store' });
      if(!res.ok){
        loading.innerText = 'Failed to load transactions (server returned ' + res.status + ')';
        return;
      }
      const arr = await res.json();
      if(!Array.isArray(arr) || arr.length === 0){
        loading.innerText = 'No transactions yet';
        return;
      }

      // Convert raw items to normalized objects and sort descending by date
      const normalized = arr.map(tx => {
        return {
          type: tx.type || '',
          amount: tx.amount || 0,
          other_party: tx.other_party || tx.to || tx.account || '',
          date: tx.date || tx.createdAt || tx.created || new Date().toISOString(),
          status: tx.status || tx.state || tx.result || null,
          raw: tx
        };
      }).sort((a,b) => new Date(b.date) - new Date(a.date));

      const grouped = groupByMonth(normalized);

      // Clear loading
      loading.style.display = 'none';

      // For each month group render header and each tx
      for(const [month, txs] of grouped){
        const mg = document.createElement('section');
        mg.className = 'month-group';

        const mt = document.createElement('div');
        mt.className = 'month-title';
        mt.textContent = month;
        mg.appendChild(mt);

        // render each tx
        for(const tx of txs){
          const card = document.createElement('div');
          card.className = 'tx-card';

          // Attempt to parse details embedded in type/raw string
          const parsed = parseTypeDetails(tx);

          // compute displayed amount (excludes fee for send-like operations)
          const displayedAmount = computeDisplayedAmount(tx, parsed);

          // Lookup human name for other party where appropriate (but for airtime we will prefer parsed network/to)
          // If parsed indicates airtime we'll not show the long 'other_party' raw string
          let lookup = null;
          if(!(parsed.kind && parsed.kind.includes('airtime'))){
            // not airtime -> try to get a friendly name (cached) for other_party
            lookup = await lookupNameForOther(tx.other_party);
          } else {
            // airtime: we still attempt lookup for the phone if desired (not necessary)
            lookup = { name: '' , avatar: null };
          }

          // decide display text
          let displayName = '';
          let metaHtml = '';
          // Airtime display: show only network and number (clean)
          if(parsed.kind && parsed.kind.includes('airtime')){
            const networkLabel = parsed.network || (tx.raw && (tx.raw.network || tx.raw.provider)) || ''; // fallback
            const targetNumber = parsed.to || tx.other_party || tx.raw?.to || tx.raw?.phone || '';
            // Name area: show network then number (single-line)
            displayName = (networkLabel ? networkLabel + ' ' : '') + (targetNumber || '').toString();
            // meta: only show date/time (no extraneous pipe strings), and amount used for airtime = parsed.value || displayedAmount
            metaHtml = `<small>${formatDateTime(tx.date)}</small>`;
          } else {
            // default behavior: show friendly name (from lookup) or other_party
            displayName = (lookup && lookup.name) ? lookup.name : (tx.other_party || '—');
            // meta shows phone/account under name and date
            const acctText = tx.other_party || (parsed.to || '') || '—';
            metaHtml = `${acctText}<br><small>${formatDateTime(tx.date)}</small>`;
          }

          // avatar
          const avatarText = avatarContent(displayName || tx.other_party);
          const av = document.createElement('div');
          av.className = 'avatar';
          if(lookup && lookup.avatar){
            const img = document.createElement('img');
            img.src = lookup.avatar;
            img.alt = displayName;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '10px';
            av.appendChild(img);
          } else {
            av.textContent = avatarText;
          }

          const mainDiv = document.createElement('div');
          mainDiv.className = 'tx-main';

          const top = document.createElement('div');
          top.className = 'tx-top';

          const left = document.createElement('div');
          left.style.minWidth = '0';

          const nameEl = document.createElement('div');
          nameEl.className = 'other-name';
          nameEl.title = displayName;
          nameEl.textContent = displayName || '—';

          const metaEl = document.createElement('div');
          metaEl.className = 'meta';
          metaEl.innerHTML = metaHtml;

          left.appendChild(nameEl);
          left.appendChild(metaEl);

          top.appendChild(left);

          const right = document.createElement('div');
          right.style.textAlign = 'right';
          const amountEl = document.createElement('div');
          amountEl.className = 'tx-amount';
          amountEl.textContent = formatCurrency(displayedAmount);

          // status label (determine best-effort)
          const st = determineStatus(tx);
          const statusEl = document.createElement('div');
          statusEl.className = `status ${st}`;
          statusEl.textContent = st;

          // direction badge (In / Out) - placed under status (as requested in the photo)
          const dir = determineDirection(tx, parsed);
          const dirText = dir === 'in' ? 'In' : 'Out';
          const dirEl = document.createElement('div');
          dirEl.className = 'direction-badge';
          dirEl.textContent = dirText;

          right.appendChild(amountEl);
          right.appendChild(statusEl);
          right.appendChild(dirEl); // <--- exact placement under status

          top.appendChild(right);
          mainDiv.appendChild(top);

          card.appendChild(av);
          card.appendChild(mainDiv);

          mg.appendChild(card);
        }

        content.appendChild(mg);
      }

    } catch (err) {
      console.error(err);
      loading.innerText = '⚠️ Failed to load transactions (network or server error).';
    }
  }

  // kick off
  window.addEventListener('load', () => {
    renderTransactions();
  });
</script>
</body>
</html>
