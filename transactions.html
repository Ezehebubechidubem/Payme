<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recent Transactions</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet"/>
  <style>
    :root{
      --primary:#00c853;
      --success:#2e7d32;
      --pending:#f0a500;
      --failed:#d32f2f;
      --bg:#ffffff;
      --card:#ffffff;
      --muted:#777;
      --line:#eee;
      --text:#111;
      --avatar-bg:#eef8f0;
      --avatar-color:#197a31;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      min-height:100vh; display:flex; flex-direction:column;
    }
    header{
      display:flex;align-items:center;gap:12px;
      padding:12px 14px;border-bottom:1px solid var(--line);
      background:#fff;position:sticky;top:0; z-index:10;
    }
    header a.back{color:var(--text); text-decoration:none; font-size:18px; width:36px; display:inline-flex; align-items:center; justify-content:center}
    header h2{flex:1;text-align:center;font-size:16px;font-weight:700;margin-right:36px}
    .container{padding:12px;flex:1;overflow:auto;}
    .month-group{margin-bottom:18px}
    .month-title{font-size:18px;font-weight:700;color:#222;margin:8px 6px}
    .tx-card{
      display:flex;align-items:center;justify-content:space-between;
      background:#fff;border-radius:10px;padding:12px;border:1px solid var(--line);
      gap:12px;margin:10px 6px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02) inset;
    }
    .left{
      display:flex;align-items:center;gap:12px;min-width:0;
    }
    .avatar{
      width:54px;height:54px;border-radius:10px;background:var(--avatar-bg);
      display:grid;place-items:center;font-weight:700;color:var(--avatar-color);flex:0 0 54px;
      overflow:hidden;
    }
    .avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .info{min-width:0}
    .name{font-weight:700;font-size:15px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .meta{font-size:13px;color:var(--muted);margin-top:6px}
    .meta .acc{display:block}
    .right{text-align:right;flex:0 0 120px}
    .amount{font-weight:800;font-size:16px;color:#111}
    .status{font-size:13px;margin-top:6px}
    .status.success{color:var(--success);font-weight:700}
    .status.pending{color:var(--pending);font-weight:700}
    .status.failed{color:var(--failed);font-weight:700}
    .tx-date{font-size:12px;color:var(--muted);margin-top:6px}
    /* responsive */
    @media (max-width:420px){
      .right{flex:0 0 110px}
      .avatar{width:48px;height:48px}
    }
    .empty{padding:30px;text-align:center;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <a class="back" href="javascript:void(0)" onclick="goBack()" title="Back"><i class="fa-solid fa-arrow-left"></i></a>
    <h2>Recent Transactions</h2>
    <div style="width:36px"></div>
  </header>

  <div class="container" id="container">
    <div class="empty">Loading transactions…</div>
  </div>

<script>
  // ---- CONFIG ----
  // Keep same API_BASE you use across the app
  const API_BASE = "https://payme-update.onrender.com";

  // ---- Helpers ----
  function goBack(){
    if (document.referrer && document.referrer !== "") window.history.back();
    else window.location.href = "paymelogin.html";
  }

  function fmtDateTime(isoOrTs){
    const d = (typeof isoOrTs === 'number') ? new Date(isoOrTs) : new Date(String(isoOrTs));
    if (isNaN(d.getTime())) return '';
    const day = String(d.getDate()).padStart(2,'0');
    const month = String(d.getMonth()+1).padStart(2,'0');
    const year = d.getFullYear();
    const hh = String(d.getHours()).padStart(2,'0');
    const mm = String(d.getMinutes()).padStart(2,'0');
    const ss = String(d.getSeconds()).padStart(2,'0');
    return `${day}/${month}/${year} , ${hh}:${mm}:${ss}`;
  }

  function monthKeyFromDate(isoOrTs){
    const d = new Date(String(isoOrTs));
    if (isNaN(d.getTime())) return 'Unknown';
    const monthNames = ["January","February","March","April","May","June","July","August","September","October","November","December"];
    return `${monthNames[d.getMonth()]} ${d.getFullYear()}`;
  }

  function currencyN(amount){
    // format with thousands separators
    const n = Number(amount) || 0;
    return '₦' + n.toLocaleString();
  }

  function statusClass(status){
    if(!status) return 'pending';
    const s = String(status).toLowerCase();
    if (s.includes('success') || s.includes('successful') || s === 'ok') return 'success';
    if (s.includes('fail') || s.includes('failed') || s.includes('error')) return 'failed';
    return 'pending';
  }

  // attempt to derive counterparty phone/account from a transaction object
  function guessCounterparty(tx, currentUser){
    // common field names
    const keys = ['other_party','other','counterparty','counter_party','to','from','receiver','sender','phone','account','account_number','to_phone','from_phone','recipient','payer','payee'];
    for (const k of keys){
      if (tx[k]) return tx[k];
    }
    // sometimes nested
    if (tx.data && typeof tx.data === 'object'){
      for (const k of keys){
        if (tx.data[k]) return tx.data[k];
      }
    }
    // if tx has "to_account" or "from_account"
    if (tx.to_account) return tx.to_account;
    if (tx.from_account) return tx.from_account;
    // fallback to null
    return null;
  }

  // fetch JSON helper
  async function fetchJson(url, opts = {}){
    try {
      const res = await fetch(url, opts);
      if (!res.ok) return null;
      const j = await res.json().catch(()=>null);
      return j;
    } catch(e){ return null; }
  }

  // fetch user info by phone or account, robust to shapes returned by backend
  async function fetchUserByPhoneOrAccount(identifier){
    if (!identifier) return null;
    // normalize: remove spaces
    const id = String(identifier).trim();
    // if looks like phone (all digits length 11 or 10), try /user/<phone>
    const digits = id.replace(/\D/g,'');
    let tries = [];

    if (digits.length >= 10 && digits.length <= 13){
      // try phone variations
      tries.push(`${API_BASE}/user/${encodeURIComponent(digits)}`);
      tries.push(`${API_BASE}/api/user/${encodeURIComponent(digits)}`);
    }

    // if length 10 and starts with 7/8/9 (agent account numbers per your spec), try by account
    if (digits.length === 10 && /^[789]\d{9}$/.test(digits)){
      tries.push(`${API_BASE}/user_by_account/${encodeURIComponent(digits)}`);
      tries.push(`${API_BASE}/api/user_by_account/${encodeURIComponent(digits)}`);
    }

    // also try raw identifier as-is (some tx fields include "0907..." with non-digit chars)
    tries.push(`${API_BASE}/user/${encodeURIComponent(id)}`);
    tries.push(`${API_BASE}/api/user/${encodeURIComponent(id)}`);
    tries.push(`${API_BASE}/user_by_account/${encodeURIComponent(id)}`);
    tries.push(`${API_BASE}/api/user_by_account/${encodeURIComponent(id)}`);

    for (const url of tries){
      const json = await fetchJson(url, { cache: 'no-store' });
      if (!json) continue;
      // accept multiple shapes:
      // {status:'success', user: {...}}
      if (json.status === 'success' && json.user && typeof json.user === 'object') return json.user;
      // {status:'success', username:.., phone:..}
      if (json.status === 'success' && json.username) {
        return { username: json.username, phone: json.phone, account_number: json.account_number, balance: json.balance, picture: json.picture || json.avatar || json.image };
      }
      // raw user object
      if (json.username || json.name || json.phone || json.account_number) {
        return { username: json.username || json.name, phone: json.phone, account_number: json.account_number, picture: json.picture || json.avatar || json.image };
      }
      // sometimes backend returns {user: {...}} nested
      if (json.user && typeof json.user === 'object') return json.user;
    }
    return null;
  }

  // create element for a txn
  function makeTxElement(tx, userCache, defaultAcc){
    const left = document.createElement('div');
    left.className = 'left';

    // avatar
    const avatar = document.createElement('div');
    avatar.className = 'avatar';

    // info block
    const info = document.createElement('div');
    info.className = 'info';

    // right block
    const right = document.createElement('div');
    right.className = 'right';

    // determine counterparty identifier and resolved user
    const counterId = tx._counterparty || tx.counterparty || tx.other_party || tx.other || tx.to || tx.from || tx.receiver || tx.sender || tx.phone || tx.account || tx.account_number || tx.recipient || null;

    // create name (use userCache if available)
    let displayName = '';
    let displayAcc = '';
    let avatarImg = null;

    if (counterId && userCache[counterId]){
      const u = userCache[counterId];
      displayName = u.username || u.name || u.displayName || '';
      avatarImg = u.picture || u.avatar || u.photo || u.image || null;
      displayAcc = u.phone || u.account_number || '';
    } else if (tx._resolved && tx._resolved.username){
      displayName = tx._resolved.username;
      avatarImg = tx._resolved.picture || tx._resolved.avatar || null;
      displayAcc = tx._resolved.phone || tx._resolved.account_number || '';
    } else {
      // fallback: show counterId directly
      displayName = (counterId && String(counterId).length>0) ? String(counterId) : (tx.note || tx.description || '—');
      displayAcc = tx.account || tx.phone || '';
    }

    // avatar image or initials
    if (avatarImg){
      const img = document.createElement('img');
      img.src = avatarImg;
      img.alt = displayName;
      avatar.appendChild(img);
    } else {
      // initials from displayName (first letters)
      let initials = '?';
      if (displayName && displayName.trim().length){
        const parts = displayName.trim().split(/\s+/);
        initials = parts.length === 1 ? (parts[0][0] || '?').toUpperCase() : ((parts[0][0]||'') + (parts[1][0]||'')).toUpperCase();
      } else if (displayAcc && displayAcc.length){
        initials = displayAcc.slice(-2);
      }
      avatar.textContent = initials;
    }

    // name line
    const nameEl = document.createElement('div');
    nameEl.className = 'name';
    nameEl.textContent = displayName || 'Unknown';

    // meta line (account/phone and amount descriptor)
    const metaEl = document.createElement('div');
    metaEl.className = 'meta';
    const accText = displayAcc ? displayAcc : (tx.phone || tx.account || '—');
    const smallAmount = currencyN(tx.amount || tx.value || tx.amt || tx.amount_value || 0);
    metaEl.innerHTML = `<span class="acc">${accText} • ${smallAmount}</span><span class="tx-date">${fmtDateTime(tx.date || tx.createdAt || tx.timestamp || tx.time || tx.tx_time || tx.txDate || tx.created || tx.datetime || Date.now())}</span>`;

    info.appendChild(nameEl);
    info.appendChild(metaEl);

    left.appendChild(avatar);
    left.appendChild(info);

    // right side
    const amountRight = document.createElement('div');
    amountRight.className = 'amount';
    amountRight.textContent = currencyN(tx.amount || tx.value || tx.amt || tx.amount_value || 0);

    const statusText = (tx.status || tx.state || tx.result || tx.condition || 'pending');
    const stClass = statusClass(statusText);

    const statusEl = document.createElement('div');
    statusEl.className = 'status ' + stClass;
    statusEl.textContent = String(statusText).toLowerCase();

    right.appendChild(amountRight);
    right.appendChild(statusEl);

    // assemble card
    const card = document.createElement('div');
    card.className = 'tx-card';
    card.appendChild(left);
    card.appendChild(right);

    return card;
  }

  // ---- Main rendering flow ----
  (async function loadAndRender(){
    const container = document.getElementById('container');
    container.innerHTML = '<div class="empty">Loading transactions…</div>';

    // get currently logged user to know which transactions to request
    const stored = (function(){ try { return JSON.parse(localStorage.getItem('loggedInUser') || localStorage.getItem('user') || 'null'); } catch(e){ return null; } })();
    if (!stored || (!stored.phone && !stored.account_number && !stored.acc)) {
      container.innerHTML = '<div class="empty">Please log in to view transactions.</div>';
      return;
    }

    // Request transactions from backend.
    // We'll try a few common endpoint shapes.
    let transactions = null;
    const phone = stored.phone || null;
    const acc = stored.account_number || stored.acc || null;
    const txEndpoints = [];
    if (phone) {
      txEndpoints.push(`${API_BASE}/transactions/${encodeURIComponent(phone)}`);
      txEndpoints.push(`${API_BASE}/api/transactions/${encodeURIComponent(phone)}`);
      txEndpoints.push(`${API_BASE}/transactions?phone=${encodeURIComponent(phone)}`);
    }
    if (acc) {
      txEndpoints.push(`${API_BASE}/transactions/account/${encodeURIComponent(acc)}`);
      txEndpoints.push(`${API_BASE}/transactions?account=${encodeURIComponent(acc)}`);
    }
    // generic fallback
    txEndpoints.push(`${API_BASE}/transactions/${encodeURIComponent(phone || acc)}`);
    txEndpoints.push(`${API_BASE}/api/transactions/${encodeURIComponent(phone || acc)}`);

    for (const url of txEndpoints){
      try {
        const res = await fetch(url, { cache: 'no-store', credentials: 'include' });
        if (!res.ok) continue;
        const j = await res.json().catch(()=>null);
        if (!j) continue;
        // Accept multiple shapes: raw array, {transactions: []}, {data: []}
        if (Array.isArray(j)) { transactions = j; break; }
        if (Array.isArray(j.transactions)) { transactions = j.transactions; break; }
        if (Array.isArray(j.data)) { transactions = j.data; break; }
        // sometimes response is {status:'success', results: [...]}
        if (Array.isArray(j.results)) { transactions = j.results; break; }
        // else try to find any array property
        for (const k of Object.keys(j || {})){
          if (Array.isArray(j[k])) { transactions = j[k]; break; }
        }
        if (Array.isArray(transactions)) break;
      } catch(e){
        // continue
      }
    }

    if (!Array.isArray(transactions) || transactions.length === 0){
      container.innerHTML = '<div class="empty">No transactions found.</div>';
      return;
    }

    // Sort descending by date (newest first). Try to read common date fields.
    transactions.sort((a,b)=>{
      const da = new Date(a.date || a.createdAt || a.timestamp || a.time || a.tx_time || a.created || a.datetime || 0).getTime() || 0;
      const db = new Date(b.date || b.createdAt || b.timestamp || b.time || b.tx_time || b.created || b.datetime || 0).getTime() || 0;
      return db - da;
    });

    // Cache for user lookups: key -> user object
    const userCache = {};
    // We'll attempt to resolve counterparty names for each transaction (deduped)
    const counterpartyIds = new Set();
    const txs = transactions.map(tx=>{
      // Normalize: pick ISO-like date or timestamp into tx._date
      tx._date = tx.date || tx.createdAt || tx.timestamp || tx.time || tx.created || tx.datetime || tx.tx_time || null;
      // derive candidate id
      const cand = guessCounterparty(tx, stored) || null;
      tx._counterparty = cand;
      if (cand) counterpartyIds.add(String(cand));
      return tx;
    });

    // Perform user fetches in parallel but with caching and throttling a bit
    const idArray = Array.from(counterpartyIds).slice(0, 200); // guard
    const fetchUserPromises = idArray.map(async id => {
      const u = await fetchUserByPhoneOrAccount(id);
      if (u) userCache[id] = u;
    });
    try { await Promise.all(fetchUserPromises); } catch(e){ /* ignore errors */ }

    // Render grouped by month
    const groups = {}; // monthKey -> [txs]
    for (const tx of txs){
      const mk = monthKeyFromDate(tx._date || Date.now());
      if (!groups[mk]) groups[mk] = [];
      groups[mk].push(tx);
    }

    // Build DOM
    container.innerHTML = '';
    // ensure months are sorted newest-first
    const monthKeys = Object.keys(groups).sort((a,b)=>{
      // parse month strings like "December 2025"
      const parseMonth = s => {
        const parts = s.split(' ');
        const monthNames = {January:0,February:1,March:2,April:3,May:4,June:5,July:6,August:7,September:8,October:9,November:10,December:11};
        const month = monthNames[parts[0]] ?? 0;
        const year = Number(parts[1]) || 0;
        return new Date(year, month, 1).getTime();
      };
      return parseMonth(b) - parseMonth(a);
    });

    for (const mk of monthKeys){
      const divGroup = document.createElement('div');
      divGroup.className = 'month-group';
      const title = document.createElement('div');
      title.className = 'month-title';
      title.textContent = mk;
      divGroup.appendChild(title);

      const arr = groups[mk];
      for (const tx of arr){
        // try to attach resolved user object into tx._resolved if available (to be used by makeTxElement)
        const id = tx._counterparty ? String(tx._counterparty) : null;
        if (id && userCache[id]) tx._resolved = userCache[id];
        // create element
        const el = makeTxElement(tx, userCache, stored.account_number || stored.phone || '');
        divGroup.appendChild(el);
      }
      container.appendChild(divGroup);
    }

  })();

</script>
</body>
</html>